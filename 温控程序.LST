C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN 温控程序.OBJ
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE 温控程序.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\INC;..\温控程
                    -序-三路温控-modebus) DEBUG OBJECTEXTEND

line level    source

   1          //  温制程序    2020-6-9
   2          //CPU STC15W4K32S4         11.0592Mhz
   3                                     
   4          
   5          #include  "STC15W4Kxx.H"
   6          #include <stdlib.h>
   7          #include "modbus.h"
   8          #include "intrins.H"  
   9          #include <stdio.h> 
  10          #include  <bin.c>
  11          #include "math.h"
  12          
  13          
  14          #define uchar  unsigned char
  15          #define uint   unsigned int
  16          #define ulong  unsigned long
  17          
  18          #define B 3950.0
  19          
  20          #define TN 298.15
  21          
  22          #define RN 10
  23          
  24          #define BaseVol 5.04 
  25          
  26          
  27          
  28          #define ADC_POWER   0x80            //ADC电源控制位
  29          #define ADC_FLAG    0x10            //ADC完成标志
  30          #define ADC_START   0x08            //ADC起始控制位
  31          #define ADC_SPEEDLL 0x00            //540个时钟
  32          #define ADC_SPEEDL  0x20            //360个时钟
  33          #define ADC_SPEEDH  0x40            //180个时钟
  34          #define ADC_SPEEDHH 0x60            //90个时钟
  35          
  36          #define CMD_IDLE    0               //空闲模式
  37          #define CMD_READ    1               //IAP字节读命令
  38          #define CMD_PROGRAM 2               //IAP字节编程命令
  39          #define CMD_ERASE   3               //IAP扇区擦除命令
  40          
  41          //#define ENABLE_IAP 0x80           //if SYSCLK<30MHz
  42          //#define ENABLE_IAP 0x81           //if SYSCLK<24MHz
  43          //#define ENABLE_IAP  0x82            //if SYSCLK<20MHz
  44          #define ENABLE_IAP 0x83           //if SYSCLK<12MHz
  45          //#define ENABLE_IAP 0x84           //if SYSCLK<6MHz
  46          //#define ENABLE_IAP 0x85           //if SYSCLK<3MHz
  47          //#define ENABLE_IAP 0x86           //if SYSCLK<2MHz
  48          //#define ENABLE_IAP 0x87           //if SYSCLK<1MHz
  49          
  50          
  51          //ID号的存放在程序区的地址为程序空间的最后7字节
  52          //#define ID_ADDR_ROM 0x03f9      //1K程序空间的MCU(如STC15F201EA, STC15F101EA)
  53          //#define ID_ADDR_ROM 0x07f9      //2K程序空间的MCU(如STC15F402EACS, STC15F202EA, STC15F102EA)
  54          //#define ID_ADDR_ROM 0x0bf9      //3K程序空间的MCU(如STC15F203EA, STC15F103EA)
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 2   

  55          //#define ID_ADDR_ROM 0x0ff9      //4K程序空间的MCU(如STC15F804EACS, STC15F404EACS, STC15F204EA, STC15F104
             -EA)
  56          //#define ID_ADDR_ROM 0x13f9      //5K程序空间的MCU(如STC15F205EA, STC15F105EA)
  57          //#define ID_ADDR_ROM 0x1ff9      //8K程序空间的MCU(如STC15F2K08S2,  STC15F808EACS, STC15F408EACS)
  58          //#define ID_ADDR_ROM 0x27f9      //10K程序空间的MCU(如STC15F410EACS)
  59          //#define ID_ADDR_ROM 0x2ff9      //12K程序空间的MCU(如STC15F812EACS, STC15F412EACS)
  60          //#define ID_ADDR_ROM 0x3ff9      //16K程序空间的MCU(如STC15F2K16S2, STC15F816EACS)
  61          //#define ID_ADDR_ROM 0x4ff9      //20K程序空间的MCU(如STC15F2K20S2, STC15F820EACS)
  62          //#define ID_ADDR_ROM 0x5ff9      //24K程序空间的MCU(如              STC15F824EACS)
  63          //#define ID_ADDR_ROM 0x6ff9      //28K程序空间的MCU(如              STC15F828EACS)
  64          #define ID_ADDR_ROM 0x7ff9      //32K程序空间的MCU(如STC15F2K32S2)
  65          //#define ID_ADDR_ROM 0x9ff9      //40K程序空间的MCU(如STC15F2K40S2)
  66          //#define ID_ADDR_ROM 0xbff9      //48K程序空间的MCU(如STC15F2K48S2)
  67          //#define ID_ADDR_ROM 0xcff9      //52K程序空间的MCU(如STC15F2K52S2)
  68          //#define ID_ADDR_ROM 0xdff9      //56K程序空间的MCU(如STC15F2K56S2)
  69          //#define ID_ADDR_ROM 0xeff9      //60K程序空间的MCU(如STC15F2K60S2)
  70          
  71          
  72          #define S1_S0 0x40              //P_SW1.6
  73          #define S1_S1 0x80              //P_SW1.7
  74          
  75          #define CCP_S0 0x10                 //P_SW1.4
  76          #define CCP_S1 0x20                 //P_SW1.5
  77          
  78          
  79          #define S2_S0 0x01              //P_SW2.0
  80          #define S3_S0 0x02              //P_SW2.1
  81          #define S4_S0 0x04              //P_SW2.2
  82          
  83          #define S2RI  0x01              //S2CON.0
  84          #define S2TI  0x02              //S2CON.1
  85          #define S2RB8 0x04              //S2CON.2
  86          #define S2TB8 0x08              //S2CON.3
  87          #define S2REN 0x10                          //S2CON.4
  88          
  89          #define S3RI  0x01              //S3CON.0
  90          #define S3TI  0x02              //S3CON.1
  91          #define S3RB8 0x04              //S3CON.2
  92          #define S3TB8 0x08              //S3CON.3
  93          
  94          #define S4RI  0x01              //S4CON.0
  95          #define S4TI  0x02              //S4CON.1
  96          #define S4RB8 0x04              //S4CON.2
  97          #define S4TB8 0x08              //S4CON.3
  98          
  99          #define PWM2345_S  0x10
 100          
 101          #define POLY        0x8005
 102          
 103          #define  nop    _nop_()
 104          
 105          #define CYCLE   4096    
 106          
 107          
 108          
 109          #define Kp 18      
 110          #define Ki 13     
 111          #define Kd 0.8    
 112          
 113          #define time_max  1450  
 114          
 115          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 3   

 116          #define   fd_key        2
 117          #define   mode_key      4
 118          #define   fn_key        3
 119          #define   power_key     0
 120          #define   up_key        1
 121          #define   dn_key        5
 122          #define   fn_up_key     9
 123          #define   fn_dn_key     13
 124          
 125          
 126          
 127          
 128          //************************************************************
 129          //485接收缓冲区
 130          unsigned char xdata g_recv_buffer[64];
 131          int xdata g_recv_buffer_index = 0;
 132          int xdata g_need_times = 10;            
 133          int xdata g_current_need_times = 0;     
 134          volatile unsigned char idata g_need_process_datas = 0;   
 135          
 136          //**************************************************************  
 137          
 138           
 139          
 140           uchar idata   key_buf;
 141                     
 142           uchar idata  t_cnt;
 143          
 144           uchar idata  fan_cnt;
 145          
 146           uchar idata  dis_temp_cnt;
 147           
 148           uchar idata  cnt3;
 149           uchar idata  cnt4;
 150           uchar idata  cnt5;
 151          
 152           uchar  idata  fan_close_cnt;
 153          
 154           uint  idata  ss_cnt;
 155          
 156           uchar idata  temp_set_cnt;
 157           uint  idata  save_cnt;
 158           
 159           uint  idata  temp[7];
 160          
 161           uint  idata  pwm5;
 162          
 163           uint  idata  fan_pwm;
 164           uchar idata  fan_num;
 165          
 166           uchar idata  mode_num;
 167           uchar idata  fenduan_num;
 168           uchar idata  hot_num;
 169           uchar idata  temp_set;
 170           uchar idata  tb_num;
 171          
 172           uchar idata  power_cnt;
 173          
 174           uchar  idata  mode_wr[5];      
 175           
 176          
 177          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 4   

 178           uchar idata lcd_03h; //显示地址缓存
 179           uchar idata lcd_06h; //显示地址缓存
 180           uchar idata lcd_07h; //显示地址缓存
 181           uchar idata lcd_0ah; //显示地址缓存
 182           uchar idata lcd_0bh; //显示地址缓存
 183           uchar idata lcd_0eh; //显示地址缓存
 184           uchar idata lcd_0fh; //显示地址缓存
 185           
 186           uint  idata  tm1;
 187           uint  idata  tm2;
 188           uint  idata  tm3;
 189           uint  idata  tm4;
 190           uint  idata  tm5;
 191           uint  idata  tm6;
 192          
 193           uint  idata  tt1;
 194           uint  idata  tt2;
 195           uint  idata  time;
 196          
 197           uchar idata out_clear_cnt;
 198           
 199           uchar idata power_run; //运行标志
 200          
 201           unsigned char idata dev_address;
 202          
 203                   
 204           unsigned long idata PeriodCnt = 0; //PWM 周期计数值
 205           uchar  idata  HighRH = 0; //高电平重载值的高字节
 206           uchar  idata  HighRL = 0; //高电平重载值的低字节
 207           uchar  idata  LowRH = 0; //低电平重载值的高字节
 208           uchar  idata  LowRL = 0; //低电平重载值的低字节
 209          
 210          
 211           uchar   xdata   ID_old[7];     
 212           uchar   xdata   ID_new[7];  
 213           uchar   code    *cptr;
 214          
 215           unsigned char code Tab[]={
 216            0xF5,0x05,0xD3,0x97,0x27,0xB6,0xF6,0x15,
 217            0xF7,0xB7,0x77,0xE6,0xF0,0xC7,0xF2,0x72,       //0~F 代码
 218            0x00, //不显示
 219            0x02,//显示-
 220            };
 221          //----------------------------------------------------------------------------------
 222                                   
 223          sbit TM1722_DIO   = P3^7;
 224          sbit TM1722_CLK   = P4^1;
 225          sbit TM1722_STB   = P3^6;
 226          
 227           
 228          sbit hot_in=P0^7;  
 229          sbit hot_ok=P0^6;  
 230          sbit hot_fan=P0^5;  
 231          sbit lcd_bl=P2^0;  
 232          
 233          sbit led1=P4^4;
 234          sbit led2=P2^6;
 235          sbit led3=P4^3;
 236          sbit led4=P2^5;
 237          sbit led5=P4^2;
 238          sbit led6=P2^4;
 239          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 5   

 240          sbit out2=P2^1;
 241          
 242          sbit out3=P2^2;
 243          
 244          sbit out1=P1^7;
 245          
 246          sbit T4=P1^3;
 247          sbit T5=P1^4;
 248          
 249          
 250          
 251          sbit speak=P5^4;
 252          //bit speak;
 253          
 254                                  
 255          bit uart_ok;
 256          bit sp_bit=1;
 257          bit clk_bit;
 258          
 259          bit zb_bit;
 260          
 261          bit dis_temp_bit;
 262          bit hot_HT_bit;
 263          
 264          bit  dis_HT_bit;
 265          bit  dis_ss_bit;
 266          
 267          bit save_bit;
 268          bit auto_bit;
 269          
 270          bit key_find_bit;
 271          bit temp_set_bit;
 272          bit ss_bit;
 273          
 274          bit hot_bit;
 275          
 276          bit power_bit;
 277          bit fan_bit;
 278          bit fan_bit2;
 279          bit fan_bit3;
 280          
 281          bit tb_num_bit;
 282          bit save_all_bit;
 283          bit mode_num_bit;
 284          bit hot_power_bit;
 285          bit power_on_bit;       //通讯命令-打开电源
 286          bit power_on_bit2;
 287          
 288           
 289          
 290          bit  PWMOUT;
 291          
 292          bit hot_fan_bit;
 293          
 294          bit fan_close_bit;
 295          bit fan_close_ok;
 296          bit tb_bit;
 297          
 298          
 299          
 300          //****************************************************************************
 301          //      MF52E 10K at 25, B = 3950, ADC = 12 bits
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 6   

 302          
 303          uint code temp_table[]={
 304          282     ,//0
 305          291     ,//1
 306          300     ,//2
 307          309     ,//3
 308          318     ,//4
 309          327     ,//5
 310          337     ,//6
 311          346     ,//7
 312          356     ,//8
 313          366     ,//9
 314          375     ,//10
 315          385     ,//11
 316          395     ,//12
 317          404     ,//13
 318          414     ,//14
 319          424     ,//15
 320          434     ,//16
 321          444     ,//17
 322          454     ,//18
 323          463     ,//19
 324          473     ,//20
 325          483     ,//21
 326          493     ,//22
 327          502     ,//23
 328          512     ,//24
 329          522     ,//25
 330          531     ,//26
 331          541     ,//27
 332          550     ,//28
 333          559     ,//29
 334          568     ,//30
 335          578     ,//31
 336          587     ,//32
 337          596     ,//33
 338          604     ,//34
 339          613     ,//35
 340          622     ,//36
 341          630     ,//37
 342          639     ,//38
 343          647     ,//39
 344          655     ,//40
 345          663     ,//41
 346          671     ,//42
 347          679     ,//43
 348          687     ,//44
 349          694     ,//45
 350          702     ,//46
 351          709     ,//47
 352          716     ,//48
 353          723     ,//49
 354          730     ,//50
 355          737     ,//51
 356          743     ,//52
 357          750     ,//53
 358          756     ,//54
 359          763     ,//55
 360          769     ,//56
 361          775     ,//57
 362          781     ,//58
 363          786     ,//59
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 7   

 364          792     ,//60
 365          797     ,//61
 366          803     ,//62
 367          808     ,//63
 368          813     ,//64
 369          818     ,//65
 370          823     ,//66
 371          828     ,//67
 372          833     ,//68
 373          837     ,//69
 374          842     ,//70
 375          846     ,//71
 376          850     ,//72
 377          854     ,//73
 378          858     ,//74
 379          862     ,//75
 380          866     ,//76
 381          870     ,//77
 382          874     ,//78
 383          877     ,//79
 384          881     ,//80
 385          884     ,//81
 386          888     ,//82
 387          891     ,//83
 388          894     ,//84
 389          897     ,//85
 390          900     ,//86
 391          903     ,//87
 392          906     ,//88
 393          909     ,//89
 394          911     ,//90
 395          914     ,//91
 396          917     ,//92
 397          919     ,//93
 398          921     ,//94
 399          924     ,//95
 400          926     ,//96
 401          928     ,//97
 402          931     ,//98
 403          933     ,//99
 404          935     ,//100
 405          937     ,//101
 406          939     ,//102
 407          941     ,//103
 408          943     ,//104
 409          945     ,//105
 410          946     ,//106
 411          948     ,//107
 412          950     ,//108
 413          952     ,//109
 414          953     ,//110
 415          955     ,//111
 416          956     ,//112
 417          958     ,//113
 418          959     ,//114
 419          961     ,//115
 420          962     ,//116
 421          964     ,//117
 422          965     ,//118
 423          966     ,//119
 424          967     //120
 425          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 8   

 426          };
 427                   
 428          //_________________________________________________________________________
 429          
 430            /*
 431          
 432          
 433          // 配置并启动 PWM，fr-频率，dc-占空比 
 434          void ConfigPWM(unsigned int fr, unsigned char dc){
 435              unsigned int high, low;
 436             
 437              PeriodCnt = (11059200/12) / fr; //计算一个周期所需的计数值   9216
 438              high = (PeriodCnt*dc) / 100; //计算高电平所需的计数值
 439              low = PeriodCnt - high; //计算低电平所需的计数值
 440              high = 65536 - high + 12; //计算高电平的重载值并补偿中断延时
 441              low = 65536 - low + 12;//计算低电平的重载值并补偿中断延时
 442             
 443              HighRH = (unsigned char)(high>>8); //高电平重载值拆分为高低字节
 444              HighRL = (unsigned char)high;
 445              LowRH = (unsigned char)(low>>8); //低电平重载值拆分为高低字节
 446              LowRL = (unsigned char)low;
 447             
 448              TMOD &= 0xF0; //清零 T0 的控制位
 449              TMOD |= 0x01; //配置 T0 为模式 1
 450              TH0 = HighRH; //加载 T0 重载值
 451              TL0 = HighRL;
 452              ET0 = 1; //使能 T0 中断
 453              TR0 = 1; //启动 T0
 454              PWMOUT = 1; //输出高电平
 455          }
 456          
 457          
 458          
 459          
 460          
 461          // 占空比调整函数，频率不变只调整占空比 
 462          void AdjustDutyCycle(uchar dc){
 463              unsigned int high, low;
 464          
 465                  if(dc>=100) dc=99;
 466                  else if(dc==0)  dc=1;
 467          
 468                  
 469              high = (PeriodCnt*dc) / 100; //计算高电平所需的计数值
 470              low = PeriodCnt - high; //计算低电平所需的计数值
 471              high = 65536 - high + 12; //计算高电平的重载值并补偿中断延时
 472              low = 65536 - low + 12;//计算低电平的重载值并补偿中断延时
 473          
 474              
 475             
 476              HighRH = (unsigned char)(high>>8); //高电平重载值拆分为高低字节
 477              HighRL = (unsigned char)high;
 478              LowRH = (unsigned char)(low>>8); //低电平重载值拆分为高低字节
 479              LowRL = (unsigned char)low;
 480          }
 481          
 482          
 483          
 484          
 485          // 关闭 PWM 
 486          void ClosePWM(void){
 487              TR0 = 0; //停止定时器
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 9   

 488              ET0 = 0; //禁止中断
 489              PWMOUT = 1; //输出高电平
 490                  
 491          }
 492          
 493            */
 494          
 495          
 496          //*******************************************************************************
 497          
 498           /*
 499          uchar ID_read_ok(void)
 500          {
 501           uchar i;
 502           cptr = ID_ADDR_ROM;         //从程序区读取ID号
 503              for (i=0; i<7; i++)         //读7个字节
 504              {
 505                 ID_old[i]= *cptr++;      
 506              }
 507            //ID数据 以下4种算法  +15  *5  /4  <<7 
 508            ID_old[0]=((ID_old[0]+15)*5/4)<<7;    
 509            ID_old[1]=((ID_old[1]+15)*5/4)<<7;
 510            ID_old[2]=((ID_old[2]+15)*5/4)<<7;
 511            ID_old[3]=((ID_old[3]+15)*5/4)<<7;
 512            ID_old[4]=((ID_old[4]+15)*5/4)<<7;
 513            ID_old[5]=((ID_old[5]+15)*5/4)<<7;
 514            ID_old[6]=((ID_old[6]+15)*5/4)<<7;
 515          
 516           cptr = 0x5f00;         //从程序区读取加密ID号  地址为0x5f00
 517              for (i=0; i<7; i++)         //读7个字节
 518              {
 519                 ID_new[i]= *cptr++;     
 520              } 
 521          
 522          
 523           for (i=0; i<7; i++){
 524                                        if(ID_old[i]!=ID_new[i])  return 1;  //比对数据不正确
 525          
 526                               }
 527           return 0;       //比对数据正确
 528          
 529          }
 530                          */
 531          
 532          /********************  计算温度 ***********************************************/
 533          // 计算结果: 0对应-40.0度, 400对应0度, 625对应25.0度, 最大1600对应120.0度. 
 534          // 为了通用, ADC输入为12bit的ADC值.
 535          // 电路和软件算法设计: Coody
 536          /**********************************************/
 537                           
 538          //#define               D_SCALE         10              //结果放大倍数, 放大10倍就是保留一位小数
 539          uint get_temperature(uint adc)
 540          {
 541   1              uint    code *p;
 542   1              uint    i;
 543   1              uchar   j,k,min,max;
 544   1              
 545   1              //adc = 4096 - adc;     //Rt接地
 546   1              p = temp_table;
 547   1              //if(adc < p[0])                return (0xfffe);
 548   1              //if(adc > p[160])      return (0xffff);
 549   1                      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 10  

 550   1              min = 0;                //0度
 551   1              max = 120;              //120度
 552   1      
 553   1              for(j=0; j<5; j++)      //对分查表
 554   1              {
 555   2                      k = min / 2 + max / 2;
 556   2                      if(adc <= p[k]) max = k;
 557   2                      else                    min = k;
 558   2              }
 559   1                       if(adc == p[min])      i = min;
 560   1              else if(adc == p[max])  i = max;
 561   1              else    // min < temp < max
 562   1              {
 563   2                      while(min <= max)
 564   2                      {
 565   3                              min++;
 566   3                              if(adc == p[min])       {i = min;       break;}
 567   3                              else if(adc < p[min])
 568   3                              {
 569   4                                      min--;
 570   4                                      //i = p[min];   //min
 571   4                                      //j = (adc - i) * D_SCALE / (p[min+1] - i);
 572   4                                      i = min;
 573   4                                      //i *= D_SCALE;
 574   4                                      //i += j;
 575   4                                      break;
 576   4                              }
 577   3                      }
 578   2              }
 579   1              return i;
 580   1      }
 581                   
 582          
 583          //************************************************************************
 584          
 585          void Delay1ms(unsigned int dd)          //@11.0592MHz
 586          {
 587   1              unsigned char i, j;
 588   1        while(dd){
 589   2                          _nop_();
 590   2                          _nop_();
 591   2                          _nop_();
 592   2                       i = 11;
 593   2                       j = 190;
 594   2                       do
 595   2                         {
 596   3                              while (--j);
 597   3                         } while (--i);
 598   2      
 599   2                           WDT_CONTR=0X34;
 600   2                               dd--;
 601   2                  }
 602   1      }
 603          
 604          
 605          //**************************************************************************
 606          /*
 607          
 608          int PID(int Set_value,int Real_value) //标准PID温度控制算法
 609          {
 610                  float uk ,uk1 ,duk;
 611                  int pid_out,e,e1 ,e2;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 11  

 612                  e=Set_value-Real_value;//误差量
 613                  duk=Kp*(e-e1)+Ki*e+Kd*(e-2*e1+e2);  //+Kd*(e-2e1+e2)
 614                  uk=uk1+duk;
 615                  pid_out=(int)uk;
 616                  uk1=uk;
 617                  e2=e1;
 618                  e1=e;
 619                  if(pid_out>1000) //1000
 620                  {
 621                          pid_out=990;//        990
 622                  }
 623                  else if(pid_out<10)         //10
 624                  {
 625                          pid_out=10;                //10
 626                  }
 627                  //outp=pid_out;
 628          
 629                  return(pid_out);
 630                         
 631          }
 632                  */
 633          
 634          //*****************************************************************************
 635          
 636          
 637          void UartInit(void)             //9600bps@11.0592MHz
 638          {
 639   1      SCON = 0x50;            //8位数据,可变波特率 串口1
 640   1      
 641   1              //S3CON = 0x10;         //8位数据,可变波特率
 642   1              //S3CON &= 0xBF;                //串口3选择定时器2为波特率发生器
 643   1      
 644   1              //S4CON = 0x10;         //8位数据,可变波特率
 645   1              //S4CON &= 0xBF;                //串口4选择定时器2为波特率发生器
 646   1      
 647   1          AUXR |= 0x01;               //串口1选择定时器2为波特率发生器
 648   1              AUXR |= 0x04;           //定时器2时钟为Fosc,即1T
 649   1              T2L = 0xE0;             //设定定时初值
 650   1              T2H = 0xFE;             //设定定时初值
 651   1              AUXR |= 0x10;           //启动定时器2
 652   1              RI=0;
 653   1              TI=0;
 654   1          ES=1;
 655   1              //S3CON &= ~S3RI;
 656   1              //S4CON &= ~S4RI;
 657   1              //IE2 = 0x08;     //打开串口3中断
 658   1      }
 659                            
 660          
 661          void Timer0Init(void)           //10ms@11.0592MHz
 662          {
 663   1              AUXR &= 0x7F;           //定时器时钟12T模式
 664   1              TMOD &= 0xF0;           //设置定时器模式
 665   1              TMOD |= 0x01;           //设置定时器模式
 666   1              TL0 = 0x00;             //设置定时初值
 667   1              TH0 = 0xDC;             //设置定时初值
 668   1              TF0 = 0;                //清除TF0标志
 669   1              TR0 = 0;                //定时器0开始计时
 670   1              ET0=0;
 671   1      }
 672          
 673          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 12  

 674          
 675          void Timer1Init(void)   
 676          {
 677   1              TMOD &= 0x0f;           //设置计数器模式
 678   1              TMOD |= 0x50;           //设置计数器模式
 679   1              TL1 = 0;                //设置定时初值
 680   1              TH1 = 0;                //设置定时重载值
 681   1          ET1=0;
 682   1              //TR1 = 1;              //定时器1开始计数
 683   1      }
 684          
 685          
 686          
 687          
 688          
 689          void Timer3Init(void)           //5毫秒@11.0592MHz
 690          {
 691   1              T4T3M |= 0x02;          //定时器时钟1T模式
 692   1              T3L = 0x00;             //设置定时初始值
 693   1              T3H = 0x28;             //设置定时初始值
 694   1              T4T3M |= 0x08;          //定时器3开始计时
 695   1              IE2 |= 0x20;       //开定时器3中断
 696   1      }
 697          
 698          
 699          
 700          
 701          /*----------------------------------------------------------------------------
 702          关闭IAP
 703          ----------------------------*/
 704          void IapIdle()
 705          {
 706   1          IAP_CONTR = 0;                  //关闭IAP功能
 707   1          IAP_CMD = 0;                    //清除命令寄存器
 708   1          IAP_TRIG = 0;                   //清除触发寄存器
 709   1          IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
 710   1          IAP_ADDRL = 0;
 711   1      }
 712          
 713          /*----------------------------
 714          从ISP/IAP/EEPROM区域读取一字节
 715          ----------------------------*/
 716          uchar IapReadByte(uint addr)
 717          {
 718   1          uchar dat;                       //数据缓冲区
 719   1      
 720   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 721   1          IAP_CMD = CMD_READ;             //设置IAP命令
 722   1          IAP_ADDRL = addr;               //设置IAP低地址
 723   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 724   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 725   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 726   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 727   1          dat = IAP_DATA;                 //读ISP/IAP/EEPROM数据
 728   1          IapIdle();                      //关闭IAP功能
 729   1      
 730   1          return dat;                     //返回
 731   1      }
 732          
 733          /*----------------------------
 734          写一字节数据到ISP/IAP/EEPROM区域
 735          ----------------------------*/
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 13  

 736          void IapProgramByte(uint addr, uchar dat)
 737          {
 738   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 739   1          IAP_CMD = CMD_PROGRAM;          //设置IAP命令
 740   1          IAP_ADDRL = addr;               //设置IAP低地址
 741   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 742   1          IAP_DATA = dat;                 //写ISP/IAP/EEPROM数据
 743   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 744   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 745   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 746   1          IapIdle();
 747   1      }
 748          
 749          /*----------------------------
 750          扇区擦除
 751          ----------------------------*/
 752          void IapEraseSector(uint addr)
 753          {
 754   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 755   1          IAP_CMD = CMD_ERASE;            //设置IAP命令
 756   1          IAP_ADDRL = addr;               //设置IAP低地址
 757   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 758   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 759   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 760   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 761   1          IapIdle();
 762   1      }
 763          
 764          //******************************************************************
 765                  
 766          void save_mode_num(void)  
 767          {
 768   1       uint addr;
 769   1       
 770   1       addr=0x0000;
 771   1       EA=0;
 772   1       IapEraseSector(addr);    
 773   1      
 774   1       IapProgramByte(addr,mode_num); 
 775   1       
 776   1                     
 777   1       EA=1;
 778   1      }
 779          
 780          
 781          void fan_close_save(void)
 782          {
 783   1       uint addr;
 784   1       
 785   1       addr=0x1000;
 786   1       EA=0;
 787   1       IapEraseSector(addr);    
 788   1      
 789   1       IapProgramByte(addr,fan_close_cnt); 
 790   1       
 791   1                     
 792   1       EA=1;
 793   1      
 794   1      }
 795          
 796          
 797          void fan_close_read(void) 
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 14  

 798          {
 799   1       uint addr;
 800   1       
 801   1       addr=0x1000;
 802   1       EA=0;
 803   1       fan_close_cnt=IapReadByte(addr);
 804   1       EA=1;
 805   1                                                                                                                                              
 806   1       if((fan_close_cnt<10)||(fan_close_cnt>250))      fan_close_cnt=120;    
 807   1      }
 808          
 809          
 810          
 811          //**********************************************************
 812          void  read_mode_wr_data(void) 
 813          {
 814   1       fenduan_num=mode_wr[0]; 
 815   1       tb_num=mode_wr[1];         
 816   1       fan_num=mode_wr[2];    
 817   1       hot_num=mode_wr[3];    
 818   1       temp_set=mode_wr[4];   
 819   1      
 820   1       if((fenduan_num==0)||(fenduan_num>7))  fenduan_num=1;
 821   1       if(tb_num>1)       tb_num=0; 
 822   1       if(fan_num>6)      fan_num=0;
 823   1       if(hot_num>100)    hot_num=50;
 824   1       if(temp_set>220)       temp_set=80;
 825   1      
 826   1      }
 827          
 828          
 829          void  save_mode_wr(void)
 830          {
 831   1       uchar n;
 832   1       uint addr;
 833   1      
 834   1       mode_wr[0]=fenduan_num; 
 835   1       mode_wr[1]=tb_num;          
 836   1       mode_wr[2]=fan_num;    
 837   1       mode_wr[3]=hot_num;    
 838   1       mode_wr[4]=temp_set;
 839   1      
 840   1       if(mode_num==1) 
 841   1         {
 842   2          addr=0x0200;
 843   2              EA=0;
 844   2              IapEraseSector(addr);    
 845   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 846   2              EA=1;
 847   2         }
 848   1      
 849   1       else if(mode_num==2) 
 850   1         {
 851   2          addr=0x0400;
 852   2              EA=0;
 853   2              IapEraseSector(addr);    
 854   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 855   2              EA=1;
 856   2         }
 857   1      
 858   1       else if(mode_num==3) 
 859   1         {
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 15  

 860   2          addr=0x0600;
 861   2              EA=0;
 862   2              IapEraseSector(addr);    
 863   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 864   2              EA=1;
 865   2         }
 866   1      
 867   1       else if(mode_num==4) 
 868   1         {
 869   2          addr=0x0800;
 870   2              EA=0;
 871   2              IapEraseSector(addr);    
 872   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 873   2              EA=1;
 874   2         }
 875   1      
 876   1       else if(mode_num==5) 
 877   1         {
 878   2          addr=0x0a00;
 879   2              EA=0;
 880   2              IapEraseSector(addr);    
 881   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 882   2              EA=1;
 883   2         }
 884   1      }
 885          
 886          
 887          void read_mode(void)
 888          {
 889   1       uint addr;
 890   1       EA=0;
 891   1       addr=0x0000;
 892   1       mode_num=IapReadByte(addr);
 893   1       
 894   1       EA=1;
 895   1      
 896   1      
 897   1       }
 898          
 899            
 900          void read_data(void)
 901          {
 902   1       uint addr;
 903   1       uchar n;
 904   1      
 905   1       if((mode_num==0)||(mode_num>5)) {mode_num=1;}
 906   1      
 907   1       if(mode_num==1) 
 908   1         {
 909   2              EA=0;
 910   2              addr=0x0200;
 911   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 912   2              EA=1;
 913   2         }
 914   1      
 915   1       else if(mode_num==2) 
 916   1         {
 917   2              EA=0;
 918   2              addr=0x0400;
 919   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 920   2              EA=1;
 921   2         }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 16  

 922   1      
 923   1       else if(mode_num==3) 
 924   1         {
 925   2              EA=0;
 926   2              addr=0x0600;
 927   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 928   2              EA=1;
 929   2         }
 930   1      
 931   1       else if(mode_num==4) 
 932   1         {
 933   2              EA=0;
 934   2              addr=0x0800;
 935   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 936   2              EA=1;
 937   2         }
 938   1      
 939   1       else if(mode_num==5) 
 940   1         {
 941   2              EA=0;
 942   2              addr=0x0a00;
 943   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 944   2              EA=1;
 945   2         }
 946   1      
 947   1       read_mode_wr_data();  
 948   1       
 949   1      
 950   1      
 951   1      
 952   1      }
 953          
 954                  
 955          
 956          
 957          
 958          //__________________________________________________________________________
 959          
 960          
 961          //***********************************************************************
 962          
 963          void InitADC(void)
 964          {
 965   1          P1ASF = B0010_0111;                   
 966   1          ADC_RES = 0;                    
 967   1          ADC_RESL=0;
 968   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL;
 969   1         
 970   1      }
 971          
 972          
 973          //----------------------------
 974          //读取ADC结果
 975          //----------------------------
 976          uint GetADCResult(uchar ch)      
 977          {
 978   1       uint dd=0;
 979   1      
 980   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL | ch | ADC_START;
 981   1          _nop_();                      
 982   1          _nop_();
 983   1          _nop_();
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 17  

 984   1          _nop_();
 985   1          while (!(ADC_CONTR & ADC_FLAG));
 986   1          ADC_CONTR &= ~ADC_FLAG;         
 987   1      
 988   1          dd= ADC_RES;                 
 989   1          dd=dd<<2;
 990   1          dd=dd|ADC_RESL;
 991   1              return dd;
 992   1      }
 993           
 994          
 995          
 996          uint Temperature_LPF(uchar ch)
 997          {
 998   1       uint a;
 999   1       uchar i,j,k;
1000   1       for(i=0;i<=6;i++)
1001   1        {
1002   2          temp[i]= GetADCResult(ch); 
1003   2          Delay1ms(5);
1004   2        }
1005   1       for(j=0;j<=6;j++)
1006   1        {                      
1007   2          for(k=j;k<=6;k++)
1008   2               {
1009   3             if(temp[j]>=temp[k])
1010   3                   {
1011   4                 a=temp[j];
1012   4                 temp[j]=temp[k];
1013   4                 temp[k]=a;
1014   4                }
1015   3            }
1016   2         }
1017   1       temp[0]=temp[6]=0;
1018   1      
1019   1      return (temp[1]+temp[2]+temp[3]+temp[4]+temp[5])/5; 
1020   1      
1021   1      }
1022          
1023          
1024          
1025          /*
1026          
1027          float Get_Tempture(uint adc)
1028          {
1029                  float RV,RT,Tmp;
1030                  RV=BaseVol/1024.0*(float)adc;//ADC为10位ADC,求出NTC电压:RV=ADCValu/1024*BaseVoltag
1031                  RT=RV*10/RV;//(BaseVol-RV);//求出当前温度阻值 (BaseVoltage-RV)/R16=RV/RT;
1032                  Tmp=1/(1/TN+(log(RT/RN)/B))-273.15;//%RT = RN exp*B(1/T-1/TN)%
1033                   return Tmp;
1034          }
1035            */
1036          
1037          
1038          
1039          
1040          
1041          /**************************************************************************
1042           - 功能描述：51单片机的串口发送字节的函数
1043           - 隶属模块：STC51串口操作
1044           - 函数属性：外部，使用户使用
1045           - 参数说明：mydata:要发送的一个字节
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 18  

1046           - 返回说明：无
1047           - 注：发送一个字节，是串口发送的基础操作
1048           **************************************************************************/
1049           
1050          void UART_Send_Byte(unsigned char mydata)       
1051          {
1052   1      
1053   1       TI=0;         //清除TI位
1054   1        
1055   1       SBUF=mydata;
1056   1       while(TI==0);
1057   1       TI=0;          //清除TI位
1058   1       
1059   1       
1060   1      }
1061          
1062           
1063          
1064          /**************************************************************************
1065           - 功能描述：51单片机的串口发送字符串
1066           - 隶属模块：STC51串口操作
1067           - 函数属性：外部，使用户使用
1068           - 参数说明：s:指向字符串的指针
1069           - 返回说明：无
1070           **************************************************************************/
1071           
1072          
1073          
1074          
1075          //*********************************************************************
1076          
1077          
1078          void Delay50us(void)            //@11.0592MHz
1079          {
1080   1              unsigned char i, j;
1081   1         
1082   1              _nop_();
1083   1              i = 1;
1084   1              j = 134;
1085   1              do
1086   1              {
1087   2                      while (--j);
1088   2              } while (--i);
1089   1       
1090   1      }
1091                             
1092          
1093          
1094                                                            
1095                        
1096          
1097          /******************************************
1098          函数：写一字节函数
1099          参数：dat---写入的一字节数据
1100          返回值：无
1101          ******************************************/
1102          void TM1722_Write_Byte(unsigned char dat)
1103          {
1104   1        unsigned char i;
1105   1               
1106   1        Delay50us(); //用于片选信号的延时
1107   1        TM1722_STB=0;     //有效的片选信号
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 19  

1108   1        for(i=0;i<8;i++)
1109   1        {
1110   2         TM1722_CLK=0;
1111   2         TM1722_DIO=dat&0x01;
1112   2         TM1722_CLK=1;    //时钟上升沿，送入一位数据
1113   2         dat>>=1;      
1114   2        }
1115   1        Delay50us();   //用于片选信号的延时
1116   1      }
1117          
1118          
1119          
1120          
1121          
1122          
1123          /******************************************
1124          函数：写一位数码管函数
1125          参数：num_addr---数码管位，num---显示数字数据
1126          返回值：无
1127          ******************************************/
1128          void TM1722_Write_Word(uchar num_addr,uchar num)
1129          {
1130   1        uchar temp1,temp2;
1131   1        uchar addr1;
1132   1        uchar addr2;
1133   1      
1134   1        if(num_addr==1)       {addr1=0xcb;  addr2=0xca;  lcd_0bh=lcd_0bh&B1111_0000; lcd_0bh=temp1=lcd_0bh|(Tab[
             -num]&0xf0)>>4;  lcd_0ah=lcd_0ah&B1111_0000; lcd_0ah=temp2=lcd_0ah|(Tab[num]&0x0f);}
1135   1        else if(num_addr==2)  {addr1=0xc7;  addr2=0xc7;  lcd_07h=lcd_07h&B0000_1000; lcd_07h=temp2=lcd_07h|Tab[n
             -um];}
1136   1        else if(num_addr==3)  {addr1=0xc6;  addr2=0xc6;  lcd_06h=lcd_06h&B0000_1000; lcd_06h=temp2=lcd_06h|Tab[n
             -um];}
1137   1       
1138   1      
1139   1      
1140   1        TM1722_STB=1;           
1141   1        TM1722_CLK=1;
1142   1        TM1722_DIO=1;
1143   1        TM1722_Write_Byte(0x00); 
1144   1        TM1722_STB=1;
1145   1        TM1722_Write_Byte(0x44);   
1146   1        TM1722_STB=1;
1147   1      
1148   1        if(num_addr!=1) goto  next_num1;
1149   1         
1150   1        TM1722_Write_Byte(addr1);
1151   1        TM1722_Write_Byte(temp1);     
1152   1        TM1722_STB=1;  
1153   1      
1154   1        next_num1: nop;
1155   1      
1156   1        TM1722_Write_Byte(addr2);//显示寄存器的00H单元开始
1157   1        TM1722_Write_Byte(temp2);     //给显示寄存器送数据，
1158   1        TM1722_STB=1;
1159   1      
1160   1        TM1722_Write_Byte(0x93); 
1161   1        TM1722_STB=1;
1162   1        
1163   1      }   
1164           
1165          
1166          void fan_dis(uchar num)   
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 20  

1167          {
1168   1        if(num==0)       {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0000_0000; }
1169   1        else if(num==1)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0100_0000; }
1170   1        else if(num==2)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_0000; }
1171   1        else if(num==3)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1000; }
1172   1        else if(num==4)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1100; }
1173   1        else if(num==5)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1110; }
1174   1        else if(num==6)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1111; }
1175   1      
1176   1        TM1722_STB=1;            //端口配置初始化
1177   1        TM1722_CLK=1;
1178   1        TM1722_DIO=1;
1179   1        TM1722_Write_Byte(0x00); //工作模式
1180   1        TM1722_STB=1;
1181   1        TM1722_Write_Byte(0x44);   //固定地址模式
1182   1        TM1722_STB=1;
1183   1       
1184   1      
1185   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1186   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1187   1        TM1722_STB=1;
1188   1      
1189   1        TM1722_Write_Byte(0x93); //显示开
1190   1        TM1722_STB=1;
1191   1        
1192   1      }   
1193          
1194          
1195          
1196          
1197          
1198          
1199          
1200          
1201          
1202          void lcd_clear(uchar dat)  
1203          {
1204   1      
1205   1        lcd_03h=dat;
1206   1        lcd_06h=dat;
1207   1        lcd_07h=dat;
1208   1        lcd_0ah=dat;
1209   1        lcd_0bh=dat;
1210   1        lcd_0eh=dat;
1211   1        lcd_0fh=dat;
1212   1      
1213   1        TM1722_STB=1;            //端口配置初始化
1214   1        TM1722_CLK=1;
1215   1        TM1722_DIO=1;
1216   1        TM1722_Write_Byte(0x00); //工作模式
1217   1        TM1722_STB=1;
1218   1        TM1722_Write_Byte(0x44);   //固定地址模式
1219   1        TM1722_STB=1;
1220   1      
1221   1                                                              
1222   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1223   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1224   1        TM1722_STB=1;
1225   1      
1226   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1227   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1228   1        TM1722_STB=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 21  

1229   1      
1230   1        TM1722_Write_Byte(0xc7);         //显示寄存器的00H单元开始
1231   1        TM1722_Write_Byte(lcd_07h);     //给显示寄存器送数据，
1232   1        TM1722_STB=1;
1233   1      
1234   1        TM1722_Write_Byte(0xca);         //显示寄存器的00H单元开始
1235   1        TM1722_Write_Byte(lcd_0ah);     //给显示寄存器送数据，
1236   1        TM1722_STB=1;
1237   1      
1238   1      
1239   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1240   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1241   1        TM1722_STB=1;
1242   1      
1243   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1244   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1245   1        TM1722_STB=1;
1246   1      
1247   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1248   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1249   1        TM1722_STB=1;
1250   1      
1251   1        TM1722_Write_Byte(0x93); 
1252   1        TM1722_STB=1;
1253   1      
1254   1      }
1255          
1256          
1257          
1258          void  dis1(bit sss,uint ss)    
1259          {
1260   1       uchar a1,a2,a3;
1261   1       if(sss)
1262   1         {
1263   2          a1=ss%1000/100;
1264   2          a2=ss%100/10;
1265   2          a3=ss%10;
1266   2      
1267   2               if(a1==0) TM1722_Write_Word(1,16);
1268   2           else      TM1722_Write_Word(1,a1);
1269   2      
1270   2               if((a1==0)&&(a2==0)) TM1722_Write_Word(2,16);
1271   2           else                 TM1722_Write_Word(2,a2); 
1272   2                
1273   2           TM1722_Write_Word(3,a3); 
1274   2          
1275   2         }
1276   1       else
1277   1        {
1278   2           TM1722_Write_Word(1,16);  
1279   2           TM1722_Write_Word(2,16);  
1280   2           TM1722_Write_Word(3,16); 
1281   2           
1282   2         }
1283   1      
1284   1      }
1285          
1286          
1287          
1288          
1289          
1290          void temp_dis(bit on_off) 
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 22  

1291          {
1292   1        if(on_off) {lcd_03h=lcd_03h|B0100_0000;       }
1293   1        else           {lcd_03h=lcd_03h&B1011_1111;   }
1294   1      
1295   1        TM1722_STB=1;            //端口配置初始化
1296   1        TM1722_CLK=1;
1297   1        TM1722_DIO=1;
1298   1        TM1722_Write_Byte(0x00); //工作模式
1299   1        TM1722_STB=1;
1300   1        TM1722_Write_Byte(0x44);   //固定地址模式
1301   1        TM1722_STB=1;
1302   1      
1303   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1304   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1305   1        TM1722_STB=1;
1306   1      
1307   1      
1308   1        TM1722_Write_Byte(0x93); 
1309   1        TM1722_STB=1;
1310   1      }
1311          
1312          
1313          
1314          void hot_dis(bit on_off) 
1315          {
1316   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_1000;       }
1317   1        else           {lcd_0eh=lcd_0eh&B1111_0111;   }
1318   1      
1319   1        TM1722_STB=1;            //端口配置初始化
1320   1        TM1722_CLK=1;
1321   1        TM1722_DIO=1;
1322   1        TM1722_Write_Byte(0x00); //工作模式
1323   1        TM1722_STB=1;
1324   1        TM1722_Write_Byte(0x44);   //固定地址模式
1325   1        TM1722_STB=1;
1326   1      
1327   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1328   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1329   1        TM1722_STB=1;
1330   1      
1331   1      
1332   1        TM1722_Write_Byte(0x93); 
1333   1        TM1722_STB=1;
1334   1      }
1335          
1336          
1337          
1338          void hot1_dis(bit on_off) 
1339          {
1340   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0100;       }
1341   1        else           {lcd_0eh=lcd_0eh&B1111_1011;   }
1342   1      
1343   1        TM1722_STB=1;            //端口配置初始化
1344   1        TM1722_CLK=1;
1345   1        TM1722_DIO=1;
1346   1        TM1722_Write_Byte(0x00); //工作模式
1347   1        TM1722_STB=1;
1348   1        TM1722_Write_Byte(0x44);   //固定地址模式
1349   1        TM1722_STB=1;
1350   1      
1351   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1352   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 23  

1353   1        TM1722_STB=1;
1354   1      
1355   1      
1356   1        TM1722_Write_Byte(0x93); 
1357   1        TM1722_STB=1;
1358   1      }
1359          
1360          
1361          
1362          
1363          
1364          void hot2_dis(bit on_off) 
1365          {
1366   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0010;       }
1367   1        else           {lcd_0eh=lcd_0eh&B1111_1101;   }
1368   1      
1369   1        TM1722_STB=1;            //端口配置初始化
1370   1        TM1722_CLK=1;
1371   1        TM1722_DIO=1;
1372   1        TM1722_Write_Byte(0x00); //工作模式
1373   1        TM1722_STB=1;
1374   1        TM1722_Write_Byte(0x44);   //固定地址模式
1375   1        TM1722_STB=1;
1376   1      
1377   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1378   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1379   1        TM1722_STB=1;
1380   1      
1381   1      
1382   1        TM1722_Write_Byte(0x93); //显示开
1383   1        TM1722_STB=1;
1384   1      }
1385             
1386          
1387          
1388          
1389          void hot3_dis(bit on_off) 
1390          {
1391   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0001;       }
1392   1        else           {lcd_0eh=lcd_0eh&B1111_1110;   }
1393   1      
1394   1        TM1722_STB=1;            //端口配置初始化
1395   1        TM1722_CLK=1;
1396   1        TM1722_DIO=1;
1397   1        TM1722_Write_Byte(0x00); //工作模式
1398   1        TM1722_STB=1;
1399   1        TM1722_Write_Byte(0x44);   //固定地址模式
1400   1        TM1722_STB=1;
1401   1      
1402   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1403   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1404   1        TM1722_STB=1;
1405   1      
1406   1      
1407   1        TM1722_Write_Byte(0x93); 
1408   1        TM1722_STB=1;
1409   1      }
1410          
1411          
1412          
1413          
1414          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 24  

1415          void H1_dis(bit on_off) 
1416          {
1417   1        if(on_off) {lcd_0bh=lcd_0bh|B0100_0000;       }
1418   1        else           {lcd_0bh=lcd_0bh&B1011_1111;   }
1419   1      
1420   1        TM1722_STB=1;            //端口配置初始化
1421   1        TM1722_CLK=1;
1422   1        TM1722_DIO=1;
1423   1        TM1722_Write_Byte(0x00); //工作模式
1424   1        TM1722_STB=1;
1425   1        TM1722_Write_Byte(0x44);   //固定地址模式
1426   1        TM1722_STB=1;
1427   1      
1428   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1429   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1430   1        TM1722_STB=1;
1431   1      
1432   1      
1433   1        TM1722_Write_Byte(0x93); 
1434   1        TM1722_STB=1;
1435   1      }
1436          
1437          
1438          void H2_dis(bit on_off) //1--显示，0--不显示     点亮 数字2  H2
1439          {
1440   1        if(on_off) {lcd_0bh=lcd_0bh|B0010_0000;       }
1441   1        else           {lcd_0bh=lcd_0bh&B1101_1111;   }
1442   1      
1443   1        TM1722_STB=1;            //端口配置初始化
1444   1        TM1722_CLK=1;
1445   1        TM1722_DIO=1;
1446   1        TM1722_Write_Byte(0x00); //工作模式
1447   1        TM1722_STB=1;
1448   1        TM1722_Write_Byte(0x44);   //固定地址模式
1449   1        TM1722_STB=1;
1450   1      
1451   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1452   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1453   1        TM1722_STB=1;
1454   1      
1455   1      
1456   1        TM1722_Write_Byte(0x93); 
1457   1        TM1722_STB=1;
1458   1      }
1459          
1460          
1461          
1462          
1463          
1464          void H3_dis(bit on_off) 
1465          {
1466   1        if(on_off) {lcd_0bh=lcd_0bh|B0001_0000;       }
1467   1        else           {lcd_0bh=lcd_0bh&B1110_1111;   }
1468   1      
1469   1        TM1722_STB=1;            //端口配置初始化
1470   1        TM1722_CLK=1;
1471   1        TM1722_DIO=1;
1472   1        TM1722_Write_Byte(0x00); //工作模式
1473   1        TM1722_STB=1;
1474   1        TM1722_Write_Byte(0x44);   //固定地址模式
1475   1        TM1722_STB=1;
1476   1      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 25  

1477   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1478   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1479   1        TM1722_STB=1;
1480   1      
1481   1      
1482   1        TM1722_Write_Byte(0x93); 
1483   1        TM1722_STB=1;
1484   1      }
1485          
1486          
1487          
1488          void tb_dis(bit on_off) 
1489          {
1490   1        if(on_off) {lcd_03h=lcd_03h|B0001_0000;       }
1491   1        else           {lcd_03h=lcd_03h&B1110_1111;   }
1492   1      
1493   1        TM1722_STB=1;            //端口配置初始化
1494   1        TM1722_CLK=1;
1495   1        TM1722_DIO=1;
1496   1        TM1722_Write_Byte(0x00); //工作模式
1497   1        TM1722_STB=1;
1498   1        TM1722_Write_Byte(0x44);   //固定地址模式
1499   1        TM1722_STB=1;
1500   1      
1501   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1502   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1503   1        TM1722_STB=1;
1504   1      
1505   1      
1506   1        TM1722_Write_Byte(0x93); 
1507   1        TM1722_STB=1;
1508   1      }
1509          
1510          
1511          
1512          
1513          
1514          
1515          
1516          void jg_dis(bit on_off) 
1517          {
1518   1        if(on_off) {lcd_03h=lcd_03h|B0010_0000;       }
1519   1        else           {lcd_03h=lcd_03h&B1101_1111;   }
1520   1      
1521   1        TM1722_STB=1;            //端口配置初始化
1522   1        TM1722_CLK=1;
1523   1        TM1722_DIO=1;
1524   1        TM1722_Write_Byte(0x00); //工作模式
1525   1        TM1722_STB=1;
1526   1        TM1722_Write_Byte(0x44);   //固定地址模式
1527   1        TM1722_STB=1;
1528   1      
1529   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1530   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1531   1        TM1722_STB=1;
1532   1      
1533   1      
1534   1        TM1722_Write_Byte(0x93); 
1535   1        TM1722_STB=1;
1536   1      }
1537          
1538          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 26  

1539          
1540          
1541          
1542          
1543          void mode_dis(bit on_off) 
1544          {
1545   1        if(on_off) {lcd_03h=lcd_03h|B1000_0000;       }
1546   1        else           {lcd_03h=lcd_03h&B0111_1111;   }
1547   1      
1548   1        TM1722_STB=1;            //端口配置初始化
1549   1        TM1722_CLK=1;
1550   1        TM1722_DIO=1;
1551   1        TM1722_Write_Byte(0x00); //工作模式
1552   1        TM1722_STB=1;
1553   1        TM1722_Write_Byte(0x44);   //固定地址模式
1554   1        TM1722_STB=1;
1555   1      
1556   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1557   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1558   1        TM1722_STB=1;
1559   1      
1560   1      
1561   1        TM1722_Write_Byte(0x93); 
1562   1        TM1722_STB=1;
1563   1      }
1564          
1565          
1566          
1567          
1568          
1569          
1570          
1571          
1572          void bf_dis(bit on_off) 
1573          {
1574   1        if(on_off) {lcd_06h=lcd_06h|B0000_1000;       }
1575   1        else           {lcd_06h=lcd_06h&B1111_0111;   }
1576   1      
1577   1        TM1722_STB=1;            //端口配置初始化
1578   1        TM1722_CLK=1;
1579   1        TM1722_DIO=1;
1580   1        TM1722_Write_Byte(0x00); //工作模式
1581   1        TM1722_STB=1;
1582   1        TM1722_Write_Byte(0x44);   //固定地址模式
1583   1        TM1722_STB=1;
1584   1      
1585   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1586   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1587   1        TM1722_STB=1;
1588   1      
1589   1      
1590   1        TM1722_Write_Byte(0x93); 
1591   1        TM1722_STB=1;
1592   1      }
1593          
1594          
1595          
1596          
1597          
1598          void set_dis(bit on_off) 
1599          {
1600   1        if(on_off) {lcd_03h=lcd_03h|B0000_0100;       }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 27  

1601   1        else           {lcd_03h=lcd_03h&B1111_1011;   }
1602   1      
1603   1        TM1722_STB=1;            //端口配置初始化
1604   1        TM1722_CLK=1;
1605   1        TM1722_DIO=1;
1606   1        TM1722_Write_Byte(0x00); //工作模式
1607   1        TM1722_STB=1;
1608   1        TM1722_Write_Byte(0x44);   //固定地址模式
1609   1        TM1722_STB=1;
1610   1      
1611   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1612   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1613   1        TM1722_STB=1;
1614   1      
1615   1      
1616   1        TM1722_Write_Byte(0x93); 
1617   1        TM1722_STB=1;
1618   1      }
1619          
1620          
1621          
1622          void cur_dis(bit on_off) 
1623          {
1624   1        if(on_off) {lcd_03h=lcd_03h|B0000_1000;       }
1625   1        else           {lcd_03h=lcd_03h&B1111_0111;   }
1626   1      
1627   1        TM1722_STB=1;           
1628   1        TM1722_CLK=1;
1629   1        TM1722_DIO=1;
1630   1        TM1722_Write_Byte(0x00); //工作模式
1631   1        TM1722_STB=1;
1632   1        TM1722_Write_Byte(0x44);   //固定地址模式
1633   1        TM1722_STB=1;
1634   1      
1635   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1636   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1637   1        TM1722_STB=1;
1638   1      
1639   1      
1640   1        TM1722_Write_Byte(0x93); 
1641   1        TM1722_STB=1;
1642   1      }
1643          
1644          
1645          
1646          
1647          void f_dis(bit on_off) 
1648          {
1649   1        if(on_off) {lcd_0eh=lcd_0eh|B1000_0000;       }
1650   1        else           {lcd_0eh=lcd_0eh&B0111_1111;   }
1651   1      
1652   1        TM1722_STB=1;            //端口配置初始化
1653   1        TM1722_CLK=1;
1654   1        TM1722_DIO=1;
1655   1        TM1722_Write_Byte(0x00); //工作模式
1656   1        TM1722_STB=1;
1657   1        TM1722_Write_Byte(0x44);   //固定地址模式
1658   1        TM1722_STB=1;
1659   1      
1660   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1661   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1662   1        TM1722_STB=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 28  

1663   1      
1664   1      
1665   1        TM1722_Write_Byte(0x93); 
1666   1        TM1722_STB=1;
1667   1      }
1668          
1669          
1670          
1671          
1672          
1673          void m_dis(bit on_off) 
1674          {
1675   1        if(on_off) {lcd_0eh=lcd_0eh|B0100_0000;       }
1676   1        else           {lcd_0eh=lcd_0eh&B1011_1111;   }
1677   1      
1678   1        TM1722_STB=1;            //端口配置初始化
1679   1        TM1722_CLK=1;
1680   1        TM1722_DIO=1;
1681   1        TM1722_Write_Byte(0x00); //工作模式
1682   1        TM1722_STB=1;
1683   1        TM1722_Write_Byte(0x44);   //固定地址模式
1684   1        TM1722_STB=1;
1685   1      
1686   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1687   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1688   1        TM1722_STB=1;
1689   1      
1690   1      
1691   1        TM1722_Write_Byte(0x93); 
1692   1        TM1722_STB=1;
1693   1      }
1694          
1695          
1696          
1697          
1698          void r_dis(bit on_off) 
1699          {
1700   1        if(on_off) {lcd_0eh=lcd_0eh|B0010_0000;       }
1701   1        else           {lcd_0eh=lcd_0eh&B1101_1111;   }
1702   1      
1703   1        TM1722_STB=1;            //端口配置初始化
1704   1        TM1722_CLK=1;
1705   1        TM1722_DIO=1;
1706   1        TM1722_Write_Byte(0x00); //工作模式
1707   1        TM1722_STB=1;
1708   1        TM1722_Write_Byte(0x44);   //固定地址模式
1709   1        TM1722_STB=1;
1710   1      
1711   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1712   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1713   1        TM1722_STB=1;
1714   1      
1715   1      
1716   1        TM1722_Write_Byte(0x93); 
1717   1        TM1722_STB=1;
1718   1      }
1719          
1720          
1721          
1722          
1723          void p1_dis(bit on_off) 
1724          {
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 29  

1725   1        if(on_off) {lcd_0ah=lcd_0ah|B0000_1000;       }
1726   1        else           {lcd_0ah=lcd_0ah&B1111_0111;   }
1727   1      
1728   1        TM1722_STB=1;            //端口配置初始化
1729   1        TM1722_CLK=1;
1730   1        TM1722_DIO=1;
1731   1        TM1722_Write_Byte(0x00); //工作模式
1732   1        TM1722_STB=1;
1733   1        TM1722_Write_Byte(0x44);   //固定地址模式
1734   1        TM1722_STB=1;
1735   1      
1736   1        TM1722_Write_Byte(0xca);         //显示寄存器的00H单元开始
1737   1        TM1722_Write_Byte(lcd_0ah);     //给显示寄存器送数据，
1738   1        TM1722_STB=1;
1739   1      
1740   1      
1741   1        TM1722_Write_Byte(0x93); 
1742   1        TM1722_STB=1;
1743   1      }
1744          
1745          
1746          
1747          
1748          void p2_dis(bit on_off) 
1749          {
1750   1        if(on_off) {lcd_07h=lcd_07h|B0000_1000;       }
1751   1        else           {lcd_07h=lcd_07h&B1111_0111;   }
1752   1      
1753   1        TM1722_STB=1;            //端口配置初始化
1754   1        TM1722_CLK=1;
1755   1        TM1722_DIO=1;
1756   1        TM1722_Write_Byte(0x00); //工作模式
1757   1        TM1722_STB=1;
1758   1        TM1722_Write_Byte(0x44);   //固定地址模式
1759   1        TM1722_STB=1;
1760   1      
1761   1        TM1722_Write_Byte(0xc7);         //显示寄存器的00H单元开始
1762   1        TM1722_Write_Byte(lcd_07h);     //给显示寄存器送数据，
1763   1        TM1722_STB=1;
1764   1      
1765   1      
1766   1        TM1722_Write_Byte(0x93); 
1767   1        TM1722_STB=1;
1768   1      }
1769          
1770          
1771          
1772          
1773          void s13_dis(bit on_off) 
1774          {
1775   1        if(on_off) {lcd_0eh=lcd_0eh|B0001_0000;       }
1776   1        else           {lcd_0eh=lcd_0eh&B1110_1111;   }
1777   1      
1778   1        TM1722_STB=1;            //端口配置初始化
1779   1        TM1722_CLK=1;
1780   1        TM1722_DIO=1;
1781   1        TM1722_Write_Byte(0x00); //工作模式
1782   1        TM1722_STB=1;
1783   1        TM1722_Write_Byte(0x44);   //固定地址模式
1784   1        TM1722_STB=1;
1785   1      
1786   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 30  

1787   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1788   1        TM1722_STB=1;
1789   1      
1790   1      
1791   1        TM1722_Write_Byte(0x93); 
1792   1        TM1722_STB=1;
1793   1      }
1794          
1795          
1796          
1797          
1798          void s14_dis(bit on_off) 
1799          {
1800   1        if(on_off) {lcd_0fh=lcd_0fh|B0001_0000;       }
1801   1        else           {lcd_0fh=lcd_0fh&B1110_1111;   }
1802   1      
1803   1        TM1722_STB=1;            //端口配置初始化
1804   1        TM1722_CLK=1;
1805   1        TM1722_DIO=1;
1806   1        TM1722_Write_Byte(0x00); //工作模式
1807   1        TM1722_STB=1;
1808   1        TM1722_Write_Byte(0x44);   //固定地址模式
1809   1        TM1722_STB=1;
1810   1      
1811   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1812   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1813   1        TM1722_STB=1;
1814   1      
1815   1      
1816   1        TM1722_Write_Byte(0x93); 
1817   1        TM1722_STB=1;
1818   1      }
1819          
1820          
1821          void s15_dis(bit on_off) 
1822          {
1823   1        if(on_off) {lcd_0fh=lcd_0fh|B0010_0000;       }
1824   1        else           {lcd_0fh=lcd_0fh&B1101_1111;   }
1825   1      
1826   1        TM1722_STB=1;            //端口配置初始化
1827   1        TM1722_CLK=1;
1828   1        TM1722_DIO=1;
1829   1        TM1722_Write_Byte(0x00); //工作模式
1830   1        TM1722_STB=1;
1831   1        TM1722_Write_Byte(0x44);   //固定地址模式
1832   1        TM1722_STB=1;
1833   1      
1834   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1835   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1836   1        TM1722_STB=1;
1837   1      
1838   1      
1839   1        TM1722_Write_Byte(0x93); 
1840   1        TM1722_STB=1;
1841   1      }
1842          
1843          
1844          
1845          
1846          
1847          
1848          void hot_select(uchar dd)
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 31  

1849          {
1850   1       switch(dd)
1851   1        {
1852   2         case 1: {hot1_dis(1); hot2_dis(0); hot3_dis(0); H1_dis(1);  H2_dis(0); H3_dis(0); }break;    
1853   2         case 2: {hot1_dis(1); hot2_dis(1); hot3_dis(0); H1_dis(1);  H2_dis(1); H3_dis(0); }break;    
1854   2         case 3: {hot1_dis(1); hot2_dis(1); hot3_dis(1); H1_dis(1);  H2_dis(1); H3_dis(1); }break;    
1855   2         case 4: {hot1_dis(1); hot2_dis(0); hot3_dis(1); H1_dis(1);  H2_dis(0); H3_dis(1); }break;    
1856   2         case 5: {hot1_dis(0); hot2_dis(1); hot3_dis(1); H1_dis(0);  H2_dis(1); H3_dis(1); }break;    
1857   2         case 6: {hot1_dis(0); hot2_dis(1); hot3_dis(0); H1_dis(0);  H2_dis(1); H3_dis(0); }break;    
1858   2         case 7: {hot1_dis(0); hot2_dis(0); hot3_dis(1); H1_dis(0);  H2_dis(0); H3_dis(1); }break;
1859   2        }
1860   1      
1861   1      
1862   1      }
1863          
1864          
1865          
1866          
1867          
1868          
1869          void  mode_chose(void)
1870          {
1871   1       read_data();
1872   1      
1873   1       lcd_clear(0x00);  
1874   1      
1875   1      
1876   1       dis1(1,mode_num); mode_dis(1);  Delay1ms(1000);  mode_dis(0);
1877   1       
1878   1       
1879   1       dis1(1,hot_num); 
1880   1       bf_dis(1);
1881   1      
1882   1       fan_dis(fan_num);
1883   1      
1884   1       hot_select(fenduan_num);
1885   1      
1886   1       if(tb_num==1)  tb_dis(1);  else  tb_dis(0); 
1887   1      
1888   1       s13_dis(1);
1889   1       s14_dis(1);
1890   1       s15_dis(1);
1891   1      }
1892          
1893          
1894          
1895          
1896          //***********************************************************************
1897          void  pwm_set(uint pwmdata)
1898          {
1899   1       
1900   1       P_SW2 |= 0x80;      
1901   1       PWM5T2 = pwmdata; 
1902   1                                                     
1903   1       P_SW2 &= ~0x80;
1904   1      
1905   1      }
1906          
1907          
1908          
1909          
1910          void fan_run(void)
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 32  

1911          {
1912   1       P_SW2 |= 0x80;    
1913   1       PWMCR =0x88;      
1914   1       P_SW2 &= ~0x80;
1915   1      
1916   1      }
1917          
1918          
1919          
1920          
1921          
1922          void fan_stop(void)
1923          {
1924   1       pwm_set(10);
1925   1       P_SW2 |= 0x80;    
1926   1       PWMCR =0x00;     
1927   1       P_SW2 &= ~0x80;
1928   1       pwm5=10;
1929   1      
1930   1      }
1931          
1932          
1933          
1934          
1935          
1936          void fan_run_stop(uchar dd)      
1937          {
1938   1       switch(dd)
1939   1        {
1940   2         case 0: { fan_stop();  fan_bit=0; }break;
1941   2      
1942   2         case 1: { fan_run(); pwm5=2000; pwm_set(pwm5); fan_bit=1;}break;
1943   2      
1944   2         case 2: { fan_run(); pwm5=2400; pwm_set(pwm5); fan_bit=1;}break;
1945   2      
1946   2         case 3: { fan_run(); pwm5=2800; pwm_set(pwm5); fan_bit=1;}break;
1947   2      
1948   2         case 4: { fan_run(); pwm5=3200; pwm_set(pwm5); fan_bit=1;}break;
1949   2      
1950   2         case 5: { fan_run(); pwm5=3600; pwm_set(pwm5); fan_bit=1;}break;
1951   2      
1952   2         case 6: { fan_run(); pwm5=4000; pwm_set(pwm5); fan_bit=1;}break;
1953   2      
1954   2        }
1955   1      
1956   1      }
1957          
1958          //***********************************************************************
1959          
1960           
1961          void send_buffer(unsigned char *buf,int len)
1962          {       
1963   1              while (len--) {
1964   2                      TI=0;     
1965   2                      SBUF = *buf++;
1966   2                      while (TI == 0);
1967   2                      TI=0;
1968   2              }
1969   1      }
1970          
1971          
1972          
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 33  

1973          
1974          
1975          void Uart() interrupt 4         
1976          {
1977   1       if (RI) {
1978   2                        RI=0;                         
1979   2          if (g_need_process_datas) return;              
1980   2                      if (g_recv_buffer_index >= 64) g_recv_buffer_index = 0;  
1981   2                      g_recv_buffer[g_recv_buffer_index++] = SBUF;   
1982   2                      g_current_need_times = g_need_times;                            
1983   2              }
1984   1       
1985   1      }
1986          //****************************************************************************************
1987          
1988          //***********************************************************************
1989          void time_inset(void)
1990          {
1991   1       tt1=time*5+57979;       
1992   1       tt2=65000;
1993   1      }
1994          
1995          
1996          
1997          void exint0()  interrupt 0 using 1        
1998          {                                          
1999   1       out1=out2=out3=1;      
2000   1       TL0 = tt1;             //设置定时初值
2001   1       TH0 = tt1>>8;  //设置定时重载值
2002   1       zb_bit=0;
2003   1       TF0=0;
2004   1       ET0=1;
2005   1       TR0=1;  
2006   1      }
2007          
2008          
2009          
2010          void tm0_isr() interrupt 1  using 2
2011          {
2012   1       if(zb_bit==0) {
2013   2                                      switch(fenduan_num)
2014   2                         {
2015   3                           case 1: {out1=0; }break;
2016   3                                               case 2: {out1=0; out2=0; }break;
2017   3                                               case 3: {out1=0; out2=0; out3=0; }break;
2018   3                                               case 4: {out1=0; out3=0; }break;
2019   3                                               case 5: {out2=0; out3=0; }break;
2020   3                                               case 6: {out2=0; }break;
2021   3                                               case 7: {out3=0; }break;
2022   3      
2023   3                                              }
2024   2                      
2025   2                      TR0=0;  
2026   2                                      TL0 = tt2;              //设置定时初值
2027   2                      TH0 = tt2>>8;   //设置定时重载值
2028   2                                      TF0=0;
2029   2                                      TR0=1;
2030   2                                      zb_bit=1;
2031   2                                      
2032   2                                  }
2033   1       else  {out1=out2=out3=1;  TR0=0; ET0=0;}
2034   1      }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 34  

2035          
2036          
2037          
2038          
2039          
2040          
2041          
2042          
2043          
2044          
2045          //******************************************************************************************
2046          
2047          
2048          
2049          
2050          
2051          
2052          void t3int() interrupt 19  using 3        //5ms  定时器3  11.0592
2053          {
2054   1      
2055   1          if (g_recv_buffer_index > 0 && g_need_process_datas == 0) 
2056   1                {
2057   2              if (g_current_need_times-- == 0) {     
2058   3                              g_need_process_datas = 1;                       
2059   3                         }            
2060   2            }
2061   1        
2062   1      
2063   1      
2064   1       key_buf=P0&0x0f; 
2065   1      
2066   1       if(fan_close_bit) 
2067   1         {
2068   2              cnt4++;
2069   2              if(cnt4>199) 
2070   2                {
2071   3                  cnt4=0; 
2072   3                      cnt5++;   
2073   3                      if(cnt5>=fan_close_cnt)  {cnt5=0; fan_close_ok=1;}
2074   3                        
2075   3                }
2076   2              
2077   2         }
2078   1      
2079   1       dis_temp_cnt++; 
2080   1       if(dis_temp_cnt>100) {dis_temp_cnt=0; dis_temp_bit=1;}
2081   1      
2082   1       
2083   1       if(fan_bit)  
2084   1         {
2085   2              fan_cnt++;
2086   2              if(fan_cnt>20)  { fan_cnt=0; fan_bit2=1; fan_bit3=~fan_bit3; }
2087   2         }  
2088   1      
2089   1      
2090   1       if(sp_bit==0)
2091   1        {
2092   2         cnt3++;
2093   2         if(cnt3>20) {cnt3=0; speak=sp_bit=1;}
2094   2        
2095   2        } 
2096   1      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 35  

2097   1      
2098   1      
2099   1      
2100   1        
2101   1      if(power_bit==0) 
2102   1        {
2103   2         
2104   2         if(power_cnt>90) { led5=~led5; power_cnt=0; }
2105   2         else power_cnt++;
2106   2      
2107   2        }      
2108   1      
2109   1      
2110   1      
2111   1      
2112   1      
2113   1      if(temp_set_bit)  
2114   1       {
2115   2        save_cnt++;
2116   2        if(save_cnt>400) {save_cnt=0;  save_bit=1; } 
2117   2      
2118   2      
2119   2        if(temp_set_cnt>90) {temp_set_cnt=0;   ss_bit=~ss_bit;}
2120   2        else temp_set_cnt++;
2121   2      
2122   2       }
2123   1      
2124   1      else {
2125   2                ss_cnt++;
2126   2                if(ss_cnt>600) { ss_cnt=0; hot_HT_bit=1;}
2127   2      
2128   2      
2129   2            }
2130   1      
2131   1               
2132   1      
2133   1      }
2134          
2135          
2136          
2137          //******************************************************************************************************
2138          
2139          void main(void)
2140          { 
2141   1      
2142   1         hot_ok=0;
2143   1         hot_fan=0;
2144   1         lcd_bl=1;
2145   1         power_bit=1;
2146   1      
2147   1          P0M0 =B0110_0000;  
2148   1          P0M1 = 0x00;
2149   1              
2150   1                       
2151   1      
2152   1          P1M0 = B1100_0000;  
2153   1          P1M1 = B0001_1000;
2154   1      
2155   1      
2156   1          P2M0 = B1000_1110; 
2157   1          P2M1 = 0x00;
2158   1      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 36  

2159   1      
2160   1          P3M0 = 0x00;   
2161   1          P3M1 = 0x00;
2162   1      
2163   1          P4M0 = 0x00;  
2164   1          P4M1 = 0x00;
2165   1      
2166   1          P5M0 = 0x00;
2167   1          P5M1 = 0x00;
2168   1      
2169   1              out1=out2=out3=1;
2170   1      
2171   1              
2172   1      //***************************************************************************
2173   1              P_SW2 |= 0x80;                  
2174   1          PWMCFG = 0x08;                  
2175   1              //PWMCR  = 0x04;                                        
2176   1          PWMCKS = 0x00;                  
2177   1          PWMC = CYCLE;                   
2178   1                        
2179   1       //----------------------------------------------------------------------------------
2180   1          PWM5T1 = 0;                  
2181   1          PWM5T2 = 10;                
2182   1                                          
2183   1          PWM5CR = 0x00;                  
2184   1       //----------------------------------------------------------------------------------
2185   1      
2186   1      
2187   1              PWMFDCR=0x30;                   
2188   1          
2189   1          //PWMCR |= 0x80;                  
2190   1      
2191   1          P_SW2 &= ~0x80;
2192   1      
2193   1      
2194   1      //**********************************************************************************
2195   1        /*     
2196   1        ACC = P_SW1;                            //串口1切换
2197   1        ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
2198   1        ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
2199   1        P_SW1 = ACC; 
2200   1                      
2201   1                */
2202   1                                                               
2203   1       
2204   1       UartInit();
2205   1      
2206   1       InitADC();
2207   1      
2208   1       Timer0Init();
2209   1      
2210   1       Timer1Init();
2211   1      
2212   1       Timer3Init();
2213   1         
2214   1       //ES=1;
2215   1      
2216   1      
2217   1       IT0 = 1;      
2218   1       
2219   1      
2220   1       EA=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 37  

2221   1       T4=T5=1;
2222   1       read_mode();   
2223   1       read_data();
2224   1       fan_close_read();
2225   1      
2226   1      
2227   1       T4=T5=1;
2228   1       nop; nop; nop;
2229   1       nop; nop; nop;
2230   1       if((T4==0)&&(T5==0))       dev_address=3;
2231   1       else if((T4==1)&&(T5==0))  dev_address=4;
2232   1       else if((T4==0)&&(T5==1))  dev_address=5;
2233   1      
2234   1       nop;
2235   1       restar: nop; nop;
2236   1      
2237   1       lcd_clear(0x00);
2238   1      
2239   1       hot_in=1;
2240   1       power_run=0;
2241   1               
2242   1       Delay1ms(50);
2243   1      
2244   1       if(key_buf==fn_key)  
2245   1        {
2246   2         speak=sp_bit=0;
2247   2         lcd_bl=0;
2248   2         led2=led1=led3=0;
2249   2         dis1(1,fan_close_cnt);
2250   2      
2251   2         while(key_buf==fn_key) WDT_CONTR=0X34;
2252   2      
2253   2         while(1)
2254   2           {
2255   3                Delay1ms(50);
2256   3      
2257   3                if(key_buf==up_key)      {speak=sp_bit=0; fan_close_cnt++; if(fan_close_cnt>250) fan_close_cnt=250; dis
             -1(1,fan_close_cnt);   Delay1ms(200);;}
2258   3      
2259   3                else if(key_buf==dn_key) {speak=sp_bit=0; fan_close_cnt--; if(fan_close_cnt<10)  fan_close_cnt=10;  dis
             -1(1,fan_close_cnt);   Delay1ms(200);}
2260   3      
2261   3                else if(key_buf==fn_key) {speak=sp_bit=0; fan_close_save();  while(key_buf==fn_key) WDT_CONTR=0X34; bre
             -ak;}
2262   3               }
2263   2              led1=led2=led3=1;
2264   2              led4=led6=1;
2265   2              lcd_clear(0x00); 
2266   2              lcd_bl=1;
2267   2        }
2268   1      
2269   1      
2270   1       led5=0;
2271   1       out_clear_cnt=0;
2272   1       
2273   1      
2274   1       while(1)
2275   1        {
2276   2         Delay1ms(2);
2277   2          nop;
2278   2              nop;
2279   2         
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 38  

2280   2               if (g_need_process_datas) {       
2281   3                      
2282   3                      if (parse_recv_buffer(g_recv_buffer,g_recv_buffer_index)==2)   
2283   3                         {   led1=~led1;}       
2284   3                                
2285   3                      g_recv_buffer_index = 0;
2286   3                      g_need_process_datas = 0;                               
2287   3                } 
2288   2      
2289   2              if(power_on_bit) { power_on_bit=0; power_on_bit2=0; lcd_bl=0; power_bit=1; power_run=1; break; }
2290   2      
2291   2              
2292   2              if(key_buf==power_key) 
2293   2          {
2294   3               speak=sp_bit=0; 
2295   3               led5=1;
2296   3               lcd_clear(0xff); 
2297   3               lcd_bl=0; 
2298   3               power_bit=1;  
2299   3               power_run=1;
2300   3               led6=0;        Delay1ms(200);
2301   3               led4=0;        Delay1ms(200);
2302   3               led2=0;        Delay1ms(200);
2303   3               led1=0;        Delay1ms(200);
2304   3               led3=0;        Delay1ms(200);
2305   3               led5=0;        
2306   3               Delay1ms(1000);
2307   3               lcd_clear(0x00);
2308   3               
2309   3               //led1=led2=led3=1;
2310   3               //led4=led6=1;
2311   3               break;
2312   3              }       
2313   2        }     
2314   1         
2315   1       
2316   1       restar2: nop; nop;
2317   1      
2318   1       led1=led2=led3=0;
2319   1       led4=led6=0;
2320   1       tb_bit=0;
2321   1      
2322   1       mode_chose();
2323   1                        
2324   1       led5=0;
2325   1      
2326   1       save_bit=0;
2327   1      
2328   1       tm1=Temperature_LPF(0);         
2329   1       tm1 =get_temperature(tm1);     
2330   1      
2331   1      
2332   1       hot_HT_bit=0;
2333   1       hot_fan_bit=0;
2334   1       ss_cnt=0;
2335   1       auto_bit=0;
2336   1      
2337   1       hot_fan=1;        
2338   1       Delay1ms(200);
2339   1       hot_fan=0;
2340   1       
2341   1       s13_dis(1); s14_dis(0);
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 39  

2342   1      
2343   1       while(1)
2344   1       {
2345   2         WDT_CONTR=0X34;
2346   2      
2347   2         if (g_need_process_datas) {       
2348   3                      
2349   3                      if (parse_recv_buffer(g_recv_buffer,g_recv_buffer_index)==2)     
2350   3                               {   led1=~led1;} 
2351   3                                
2352   3                      g_recv_buffer_index = 0;
2353   3                      g_need_process_datas = 0;                       
2354   3              }
2355   2      
2356   2              if(save_all_bit) 
2357   2                {
2358   3                 save_all_bit=0;
2359   3      
2360   3                  save_mode_wr();    
2361   3                      fan_close_save();
2362   3                 goto  restar2;
2363   3                }
2364   2                
2365   2      
2366   2              if(mode_num_bit)  
2367   2                {
2368   3                  mode_num_bit=0;
2369   3                      mode_chose(); 
2370   3                      save_mode_num();
2371   3      
2372   3                }
2373   2      
2374   2               if(tb_num_bit)  
2375   2                {
2376   3                 tb_num_bit=0;
2377   3      
2378   3                 if(tb_num==0) tb_dis(0);
2379   3      
2380   3                 else          tb_dis(1);
2381   3                        
2382   3                      save_mode_wr();
2383   3                      fan_bit=0;
2384   3                                       
2385   3                      led1=led2=led3=1;
2386   3                  led4=led5=led6=1;
2387   3      
2388   3                  EX0=0; TR1=0; ET0=0;         
2389   3                      out1=out2=out3=1;
2390   3      
2391   3                      hot_dis(0);  
2392   3      
2393   3                      fan_stop(); 
2394   3      
2395   3                      goto  restar2;
2396   3                }
2397   2      
2398   2          if(power_on_bit2)   
2399   2               {
2400   3                 power_on_bit2=0;
2401   3                             lcd_clear(0x00); 
2402   3                             lcd_bl=1;
2403   3                                         fan_bit=0;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 40  

2404   3                                         auto_bit=0;
2405   3                                         led1=led2=led3=1;
2406   3                             led4=led5=led6=1;
2407   3      
2408   3                                         power_run=0;
2409   3                                         hot_fan=0;
2410   3      
2411   3                                         EX0=0; TR1=0; ET0=0;  
2412   3                                         out1=out2=out3=1;
2413   3      
2414   3                                         hot_dis(0);  
2415   3      
2416   3                                         fan_stop();  
2417   3                                         goto  restar;
2418   3      
2419   3                }
2420   2      
2421   2         if(tb_num==1) 
2422   2           {
2423   3      
2424   3              if(hot_in==0)  
2425   3               {
2426   4                     if(tb_bit==0)
2427   4                               { 
2428   5                                tb_bit=1;
2429   5                                auto_bit=0;
2430   5                                fan_close_bit=0; 
2431   5      
2432   5                                fan_run_stop(fan_num);  
2433   5      
2434   5                                hot_dis(1);  
2435   5      
2436   5                                time=hot_num*14; if(time>time_max)  time=time_max;  
2437   5                                time_inset();
2438   5                                TH1=TL1=0; IE0=0; EX0=1;                                                
2439   5      
2440   5      
2441   5                        }
2442   4                    }
2443   3                       else { 
2444   4                                 if(tb_bit==1)
2445   4                                   {
2446   5                                         tb_bit=0;
2447   5                                     auto_bit=0;
2448   5                                         cnt4=cnt5=0;
2449   5                                         fan_close_bit=1;  
2450   5      
2451   5                                         hot_dis(0); 
2452   5      
2453   5                                         EX0=0; TR1=0; ET0=0;  
2454   5                                         out1=out2=out3=1;
2455   5                                        }
2456   4      
2457   4                                      if(fan_close_ok) {fan_close_ok=0; fan_stop(); fan_bit=0;}
2458   4      
2459   4                             }
2460   3      
2461   3                }
2462   2      
2463   2              else { 
2464   3                        if(auto_bit==0)
2465   3                          {
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 41  

2466   4                               auto_bit=1;
2467   4                               
2468   4                               fan_run_stop(fan_num); 
2469   4      
2470   4                               hot_dis(1); 
2471   4      
2472   4                               time=hot_num*14; if(time>time_max)     time=time_max;  
2473   4                               time_inset();
2474   4                               TH1=TL1=0; IE0=0; EX0=1; 
2475   4                              }
2476   3      
2477   3                   }
2478   2      
2479   2      
2480   2      
2481   2         
2482   2         if(fan_bit2) { fan_bit2=0;  if(fan_bit3) {s13_dis(1); s14_dis(0);} else {s13_dis(0); s14_dis(1);} }
2483   2      
2484   2      
2485   2      
2486   2      
2487   2         if(dis_temp_bit)
2488   2          {
2489   3               dis_temp_bit=0;
2490   3      
2491   3           tm1=Temperature_LPF(0);
2492   3           tm1 =get_temperature(tm1); 
2493   3      
2494   3               tm6=Temperature_LPF(5);        
2495   3           tm6 =get_temperature(tm6); 
2496   3      
2497   3               if((dis_ss_bit==1)&&(temp_set_bit==0))  { if(tm1>0) dis1(1,tm1); }
2498   3      
2499   3               if(tm1>=temp_set)   hot_ok=1; 
2500   3               else                hot_ok=0;
2501   3      
2502   3      
2503   3               if((tm6>45)&&(hot_fan_bit==0))      {  hot_fan=1;   hot_fan_bit=1; } 
2504   3      
2505   3               else if((tm6<40)&&(hot_fan_bit==1)) {  hot_fan=0;   hot_fan_bit=0; power_bit=1; led5=0;} 
2506   3      
2507   3               if(tm6>100)  { power_bit=0; if(led5) {speak=sp_bit=0; jg_dis(0);} else jg_dis(1); }
2508   3      
2509   3                if(tm6>118)  { 
2510   4                               EX0=0; TR1=0; ET0=0;    
2511   4                                           out1=out2=out3=1; 
2512   4                                               hot_dis(0);  
2513   4                                               jg_dis(1);
2514   4                                               hot_ok=1; 
2515   4                                                
2516   4                                               while(1){
2517   5                                                                Delay1ms(100);
2518   5                                                                if(led5) { speak=sp_bit=0;  }
2519   5                                                                
2520   5                                                                if(key_buf==power_key)  
2521   5                                                                      {
2522   6                                                                        speak=sp_bit=0;
2523   6                                                        lcd_clear(0x00); 
2524   6                                            lcd_bl=1;
2525   6                                                        fan_bit=0;
2526   6                                                        auto_bit=0;
2527   6                                                        led1=led2=led3=1;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 42  

2528   6                                            led4=led5=led6=1;
2529   6      
2530   6                                                        EX0=0; TR1=0; ET0=0;   
2531   6                                                        out1=out2=out3=1;
2532   6      
2533   6                                                        fan_stop();  
2534   6      
2535   6                                                        while(key_buf==power_key) WDT_CONTR=0X34;
2536   6      
2537   6                                                        goto  restar;
2538   6      
2539   6                                                                      }
2540   5                                                       }
2541   4      
2542   4                                         }
2543   3      
2544   3              }
2545   2      
2546   2      
2547   2      
2548   2      
2549   2      
2550   2         if(hot_HT_bit) 
2551   2            {
2552   3                 hot_HT_bit=0;                
2553   3                                         
2554   3      
2555   3             if(dis_ss_bit) {dis_ss_bit=0; temp_dis(0); bf_dis(1); dis1(1,hot_num); }  
2556   3                
2557   3                 else           {dis_ss_bit=1; if(tm1>0) {temp_dis(1); bf_dis(0); dis1(1,tm1);}} 
2558   3                } 
2559   2         
2560   2      
2561   2      
2562   2      
2563   2      
2564   2      
2565   2      
2566   2                                              
2567   2         
2568   2         if(save_bit) {save_bit=0; temp_set_bit=0; hot_HT_bit=1; save_mode_wr(); }
2569   2      
2570   2      
2571   2      
2572   2      
2573   2      
2574   2         if(key_buf==power_key)  
2575   2            {
2576   3                  t_cnt=150;
2577   3                                  
2578   3              while((key_buf==power_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2579   3                  if(t_cnt==0)  
2580   3                                    {
2581   4                                         speak=sp_bit=0;
2582   4                                         lcd_clear(0x00); 
2583   4                             lcd_bl=1;
2584   4                                         fan_bit=0;
2585   4                                         auto_bit=0;
2586   4                                         led1=led2=led3=1;
2587   4                             led4=led5=led6=1;
2588   4      
2589   4                                         power_run=0;
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 43  

2590   4                                         hot_fan=0;
2591   4      
2592   4                                         EX0=0; TR1=0; ET0=0;  
2593   4                                         out1=out2=out3=1;
2594   4      
2595   4                                         hot_dis(0);  
2596   4      
2597   4                                         fan_stop();  
2598   4      
2599   4                                         while(key_buf==power_key) WDT_CONTR=0X34;
2600   4      
2601   4                                         goto  restar;
2602   4      
2603   4                                        }
2604   3                }
2605   2      
2606   2      
2607   2               
2608   2              if((key_buf==fn_key)&&(power_bit==0))      {speak=sp_bit=0;     power_bit=1; led5=0;  while(key_buf==fn_key)
             - WDT_CONTR=0X34;}
2609   2      
2610   2      
2611   2          
2612   2         if(key_buf==fn_up_key)      {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; fan_num++; if(fan_num>6)   fan
             -_num=6;     fan_dis(fan_num); if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==fn_up_ke
             -y) WDT_CONTR=0X34;}
2613   2      
2614   2         
2615   2         else if(key_buf==fn_dn_key) {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; if(fan_num==0) fan_num=0; else
             - fan_num--; fan_dis(fan_num); if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==fn_dn_ke
             -y) WDT_CONTR=0X34;}
2616   2      
2617   2         
2618   2         else if(key_buf==up_key)    
2619   2             {
2620   3                   speak=sp_bit=0; temp_dis(0); bf_dis(1); temp_set_bit=1; 
2621   3      
2622   3                       save_cnt=0; hot_num+=5; if(hot_num>100) hot_num=100; dis1(1,hot_num); 
2623   3      
2624   3                       time=hot_num*14; if(time>time_max)     time=time_max;  time_inset();
2625   3      
2626   3                       if(hot_bit)  {hot_bit=0; TH1=TL1=0; IE0=0; EX0=1; }
2627   3      
2628   3                       while(key_buf==up_key) WDT_CONTR=0X34;
2629   3                      }
2630   2      
2631   2         
2632   2         else if(key_buf==dn_key)  
2633   2             {
2634   3                  speak=sp_bit=0; temp_dis(0); bf_dis(1); temp_set_bit=1;
2635   3      
2636   3                  save_cnt=0; if(hot_num>=5) hot_num-=5;  dis1(1,hot_num);
2637   3      
2638   3                      if(hot_num<5) {hot_num=0; EX0=0; TR1=0; ET0=0; out1=out2=out3=1; if(tb_num==0) hot_bit=1;} 
2639   3      
2640   3                      else {time=hot_num*14; if(time>time_max)        time=time_max;  time_inset(); }
2641   3      
2642   3                      while(key_buf==dn_key) WDT_CONTR=0X34;
2643   3                      
2644   3                 }
2645   2      
2646   2      
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 44  

2647   2         
2648   2         if(key_buf==mode_key)  
2649   2          {
2650   3               t_cnt=150;
2651   3                                  
2652   3            while((key_buf==mode_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2653   3                if(t_cnt==0)  
2654   3                                    {
2655   4                                         speak=sp_bit=0;
2656   4      
2657   4                                         if(tb_num==0) {tb_num=1; tb_dis(1);}
2658   4      
2659   4                                         else          {tb_num=0; tb_dis(0);}
2660   4      
2661   4                                         while(key_buf==mode_key) WDT_CONTR=0X34;
2662   4      
2663   4                                        
2664   4                                         save_mode_wr();
2665   4      
2666   4                                         fan_bit=0;
2667   4                                       
2668   4                                         led1=led2=led3=1;
2669   4                             led4=led5=led6=1;
2670   4      
2671   4                                         EX0=0; TR1=0; ET0=0;  
2672   4                                         out1=out2=out3=1;
2673   4      
2674   4                                         hot_dis(0);  
2675   4      
2676   4                                         fan_stop();  
2677   4      
2678   4                                         goto  restar2;
2679   4                                        }
2680   3      
2681   3                 else { speak=sp_bit=0; fan_bit=0; auto_bit=0; temp_set_bit=1; save_cnt=0; mode_num+=1; if(mode_num>5) 
             -mode_num=1; mode_chose(); save_mode_num(); while(key_buf==mode_key) WDT_CONTR=0X34; }
2682   3                               
2683   3              }
2684   2      
2685   2         
2686   2         
2687   2         
2688   2         if(key_buf==fd_key) 
2689   2           { 
2690   3                                t_cnt=150;
2691   3                                  
2692   3      
2693   3                            while((key_buf==fd_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2694   3      
2695   3                                if(t_cnt==0) 
2696   3                                    {
2697   4                                         speak=sp_bit=0; 
2698   4                                         temp_dis(1);
2699   4                                         bf_dis(0);
2700   4                                         dis1(1,temp_set);
2701   4                                         temp_set_bit=1;
2702   4                                         while(key_buf==fd_key) 
2703   4                                           {
2704   5                                                 WDT_CONTR=0X34;
2705   5      
2706   5                                                 if(ss_bit) dis1(1,temp_set);  else dis1(0,temp_set);
2707   5                                               }
C51 COMPILER V9.60.7.0   ________                                                          11/08/2024 16:15:52 PAGE 45  

2708   4      
2709   4      
2710   4                                         while(1)
2711   4                                           {
2712   5                                                Delay1ms(30);
2713   5      
2714   5                                                if(ss_bit) dis1(1,temp_set);  else dis1(0,temp_set);
2715   5      
2716   5                                                if(key_buf==up_key)         {speak=sp_bit=0; temp_set+=1; if(temp_set>200) temp_set=200; dis1(1,tem
             -p_set); Delay1ms(150);}
2717   5      
2718   5         
2719   5                            else if(key_buf==dn_key)    {speak=sp_bit=0; temp_set-=1; if(temp_set<50) temp_set=5
             -0;   dis1(1,temp_set); Delay1ms(150);}
2720   5      
2721   5      
2722   5                                                else if(key_buf==fd_key)        {speak=sp_bit=0; while(key_buf==fd_key) WDT_CONTR=0X34; save_mode_wr(); 
             -break;}
2723   5      
2724   5                                               }
2725   4      
2726   4                                         
2727   4                                         temp_set_bit=0;
2728   4                                         save_bit=0;
2729   4                                         temp_dis(0);
2730   4                                         bf_dis(1);
2731   4                                         dis1(1,hot_num);
2732   4                                                
2733   4                                        }
2734   3                                else {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; fenduan_num++; if(fenduan_num>7) fenduan_num=1; hot
             -_select(fenduan_num); while(key_buf==fd_key) WDT_CONTR=0X34;}
2735   3                                              
2736   3                }
2737   2         
2738   2                        
2739   2      
2740   2        
2741   2         
2742   2       }
2743   1                         
2744   1         
2745   1      
2746   1      
2747   1      }
2748          
2749          
2750           
2751                   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5915    ----
   CONSTANT SIZE    =    260    ----
   XDATA SIZE       =     86      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     80    ----
   BIT SIZE         =     29      23
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
