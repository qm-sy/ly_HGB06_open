C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ________
OBJECT MODULE PLACED IN .\output\温控程序.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE 温控程序.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\INC) DEBUG OBJECTEX
                    -TEND OBJECT(.\output\温控程序.obj)

line level    source

   1          //  温制程序    2020-6-9
   2          //CPU STC15W4K32S4         11.0592Mhz
   3          
   4          //2022-12-17  增加了上电out1=out2=out3=1  ,在待机时每秒都会输出关闭信号 
   5          //2023-4-21   修改了 风扇输出频率，原2.7Khz  改为225hz
   6          //2024-4-10   修改了风扇风量值
   7          //对应坚诺名称：温控程序C-200hz-AC50Hz-120秒       
   8          //对应坚诺名称：温控程序E-200hz-AC50Hz-15秒       两个文件只是时间不同
   9          
  10          
  11          
  12          #include  "STC15W4Kxx.H"
  13          #include <stdlib.h>
  14          #include "intrins.H"  //_nop_()
  15          #include <stdio.h> //sprintf 用此函数
  16          #include  <bin.c>
  17          #include "math.h"
  18          
  19          
  20          #define uchar  unsigned char
  21          #define uint   unsigned int
  22          #define ulong  unsigned long
  23          
  24          #define B 3950.0//温度系数
  25          
  26          #define TN 298.15//额定温度(绝对温度加常温:273.15+25)
  27          
  28          #define RN 10// 额定阻值(绝对温度时的电阻值10k)
  29          
  30          #define BaseVol 5.04 //ADC基准电压
  31          
  32          
  33          
  34          #define ADC_POWER   0x80            //ADC电源控制位
  35          #define ADC_FLAG    0x10            //ADC完成标志
  36          #define ADC_START   0x08            //ADC起始控制位
  37          #define ADC_SPEEDLL 0x00            //540个时钟
  38          #define ADC_SPEEDL  0x20            //360个时钟
  39          #define ADC_SPEEDH  0x40            //180个时钟
  40          #define ADC_SPEEDHH 0x60            //90个时钟
  41          
  42          #define CMD_IDLE    0               //空闲模式
  43          #define CMD_READ    1               //IAP字节读命令
  44          #define CMD_PROGRAM 2               //IAP字节编程命令
  45          #define CMD_ERASE   3               //IAP扇区擦除命令
  46          
  47          //#define ENABLE_IAP 0x80           //if SYSCLK<30MHz
  48          //#define ENABLE_IAP 0x81           //if SYSCLK<24MHz
  49          //#define ENABLE_IAP  0x82            //if SYSCLK<20MHz
  50          #define ENABLE_IAP 0x83           //if SYSCLK<12MHz
  51          //#define ENABLE_IAP 0x84           //if SYSCLK<6MHz
  52          //#define ENABLE_IAP 0x85           //if SYSCLK<3MHz
  53          //#define ENABLE_IAP 0x86           //if SYSCLK<2MHz
  54          //#define ENABLE_IAP 0x87           //if SYSCLK<1MHz
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 2   

  55          
  56          
  57          //ID号的存放在程序区的地址为程序空间的最后7字节
  58          //#define ID_ADDR_ROM 0x03f9      //1K程序空间的MCU(如STC15F201EA, STC15F101EA)
  59          //#define ID_ADDR_ROM 0x07f9      //2K程序空间的MCU(如STC15F402EACS, STC15F202EA, STC15F102EA)
  60          //#define ID_ADDR_ROM 0x0bf9      //3K程序空间的MCU(如STC15F203EA, STC15F103EA)
  61          //#define ID_ADDR_ROM 0x0ff9      //4K程序空间的MCU(如STC15F804EACS, STC15F404EACS, STC15F204EA, STC15F104
             -EA)
  62          //#define ID_ADDR_ROM 0x13f9      //5K程序空间的MCU(如STC15F205EA, STC15F105EA)
  63          //#define ID_ADDR_ROM 0x1ff9      //8K程序空间的MCU(如STC15F2K08S2,  STC15F808EACS, STC15F408EACS)
  64          //#define ID_ADDR_ROM 0x27f9      //10K程序空间的MCU(如STC15F410EACS)
  65          //#define ID_ADDR_ROM 0x2ff9      //12K程序空间的MCU(如STC15F812EACS, STC15F412EACS)
  66          //#define ID_ADDR_ROM 0x3ff9      //16K程序空间的MCU(如STC15F2K16S2, STC15F816EACS)
  67          //#define ID_ADDR_ROM 0x4ff9      //20K程序空间的MCU(如STC15F2K20S2, STC15F820EACS)
  68          //#define ID_ADDR_ROM 0x5ff9      //24K程序空间的MCU(如              STC15F824EACS)
  69          //#define ID_ADDR_ROM 0x6ff9      //28K程序空间的MCU(如              STC15F828EACS)
  70          #define ID_ADDR_ROM 0x7ff9      //32K程序空间的MCU(如STC15F2K32S2)
  71          //#define ID_ADDR_ROM 0x9ff9      //40K程序空间的MCU(如STC15F2K40S2)
  72          //#define ID_ADDR_ROM 0xbff9      //48K程序空间的MCU(如STC15F2K48S2)
  73          //#define ID_ADDR_ROM 0xcff9      //52K程序空间的MCU(如STC15F2K52S2)
  74          //#define ID_ADDR_ROM 0xdff9      //56K程序空间的MCU(如STC15F2K56S2)
  75          //#define ID_ADDR_ROM 0xeff9      //60K程序空间的MCU(如STC15F2K60S2)
  76          
  77          
  78          #define S1_S0 0x40              //P_SW1.6
  79          #define S1_S1 0x80              //P_SW1.7
  80          
  81          #define CCP_S0 0x10                 //P_SW1.4
  82          #define CCP_S1 0x20                 //P_SW1.5
  83          
  84          
  85          #define S2_S0 0x01              //P_SW2.0
  86          #define S3_S0 0x02              //P_SW2.1
  87          #define S4_S0 0x04              //P_SW2.2
  88          
  89          #define S2RI  0x01              //S2CON.0
  90          #define S2TI  0x02              //S2CON.1
  91          #define S2RB8 0x04              //S2CON.2
  92          #define S2TB8 0x08              //S2CON.3
  93          #define S2REN 0x10                          //S2CON.4
  94          
  95          #define S3RI  0x01              //S3CON.0
  96          #define S3TI  0x02              //S3CON.1
  97          #define S3RB8 0x04              //S3CON.2
  98          #define S3TB8 0x08              //S3CON.3
  99          
 100          #define S4RI  0x01              //S4CON.0
 101          #define S4TI  0x02              //S4CON.1
 102          #define S4RB8 0x04              //S4CON.2
 103          #define S4TB8 0x08              //S4CON.3
 104          
 105          #define PWM2345_S  0x10
 106          
 107          #define POLY        0x8005
 108          
 109          #define  nop    _nop_()
 110          
 111          #define CYCLE   4096     //定义PWM周期
 112          
 113          
 114          
 115          #define Kp 18      //比例系数 18
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 3   

 116          #define Ki 13     //积分系数  13
 117          #define Kd 0.8    //微分系数 0.3
 118          
 119          #define time_max  6400  //输出最高电压值
 120          
 121          
 122          #define   fd_key        2
 123          #define   mode_key      4
 124          #define   fn_key        3
 125          #define   power_key     0
 126          #define   up_key        1
 127          #define   dn_key        5
 128          #define   fn_up_key     9
 129          #define   fn_dn_key     13
 130          
 131          
 132          
 133          
 134          //************************************************************
 135             /*
 136             float idata Rt;
 137             float idata Rp;
 138             float idata T2;
 139             float idata Bx;
 140             float idata Ka;
 141             float idata vol;      */
 142          
 143           uchar  idata  keybuf;
 144          
 145           uchar  idata  ribuf1[20];   //串口1接收数组
 146          
 147          
 148           uchar  idata  buff[20];
 149           uchar  idata  ri_cnt;
 150           uchar  idata  jj;
 151           uchar  idata  nn[3];
 152          
 153           uchar idata   uu[2];
 154          
 155           uchar idata   key_buf;
 156                     
 157           uchar idata  t_cnt;
 158          
 159           uchar idata  fan_cnt;
 160          
 161           uchar idata  dis_temp_cnt;
 162           
 163           uchar idata  cnt3;
 164           uchar idata  cnt4;
 165           uchar idata  cnt5;
 166          
 167           uchar  idata  fan_close_cnt;
 168          
 169           uchar idata  ss_cnt;
 170          
 171           uchar idata  temp_set_cnt;
 172           uchar idata  save_cnt;
 173           
 174           uint  idata  temp[7];
 175          
 176           uint  idata  pwm5;
 177          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 4   

 178           uint  idata  fan_pwm;
 179           uchar idata  fan_num;
 180          
 181           uchar idata  mode_num;
 182           uchar idata  fenduan_num;
 183           uchar idata  hot_num;
 184           uchar idata  temp_set;
 185           uchar idata  tb_num;
 186          
 187           uchar idata  power_cnt;
 188          
 189           uchar  idata  mode_wr[5];      //存储每个模式中的5个参数
 190           
 191          
 192          
 193           uchar idata lcd_03h; //显示地址缓存
 194           uchar idata lcd_06h; //显示地址缓存
 195           uchar idata lcd_07h; //显示地址缓存
 196           uchar idata lcd_0ah; //显示地址缓存
 197           uchar idata lcd_0bh; //显示地址缓存
 198           uchar idata lcd_0eh; //显示地址缓存
 199           uchar idata lcd_0fh; //显示地址缓存
 200           
 201           uint  idata  tm1;
 202           uint  idata  tm2;
 203           uint  idata  tm3;
 204           uint  idata  tm4;
 205           uint  idata  tm5;
 206           uint  idata  tm6;
 207          
 208           uint  idata  tt1;
 209           uint  idata  tt2;
 210           uint  idata  time;
 211          
 212           uchar idata out_clear_cnt;
 213           
 214          bit preheating_scan_bit = 0;  
 215          bit preheating_strat_bit = 0;  
 216           unsigned long preheating_scan_cnt = 0;
 217           unsigned long preheating_strat_cnt = 0;
 218          turn_bit = 0;      
 219          
 220                   
 221           unsigned long idata PeriodCnt = 0; //PWM 周期计数值
 222           uchar  idata  HighRH = 0; //高电平重载值的高字节
 223           uchar  idata  HighRL = 0; //高电平重载值的低字节
 224           uchar  idata  LowRH = 0; //低电平重载值的高字节
 225           uchar  idata  LowRL = 0; //低电平重载值的低字节
 226          
 227          
 228           uchar   xdata   ID_old[7];     //芯片ID数据
 229           uchar   xdata   ID_new[7]; //加密ID后的数据 
 230           uchar   code    *cptr;
 231          
 232           unsigned char code Tab[]={
 233            0xF5,0x05,0xD3,0x97,0x27,0xB6,0xF6,0x15,
 234            0xF7,0xB7,0x77,0xE6,0xF0,0xC7,0xF2,0x72,       //0~F 代码
 235            0x00, //不显示
 236            0x02,//显示-
 237            };
 238          //----------------------------------------------------------------------------------
 239                                   
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 5   

 240          sbit TM1722_DIO   = P3^7;
 241          sbit TM1722_CLK   = P4^1;
 242          sbit TM1722_STB   = P3^6;
 243          
 244           
 245          sbit hot_in=P0^7;  
 246          sbit hot_ok=P0^6;  
 247          sbit hot_fan=P0^5;  
 248          sbit lcd_bl=P2^0;  
 249          
 250          sbit led1=P4^4;
 251          sbit led2=P2^6;
 252          sbit led3=P4^3;
 253          sbit led4=P2^5;
 254          sbit led5=P4^2;
 255          sbit led6=P2^4;
 256          
 257          sbit out2=P2^1;
 258          
 259          sbit out3=P2^2;
 260          
 261          sbit out1=P1^7;
 262          
 263          
 264          
 265          sbit speak=P5^4;
 266          //bit speak;
 267          
 268                                  
 269          bit uart_ok;
 270          bit sp_bit=1;
 271          bit clk_bit;
 272          
 273          bit zb_bit;
 274          
 275          bit dis_temp_bit;
 276          bit hot_HT_bit;
 277          
 278          bit  dis_HT_bit;
 279          bit  dis_ss_bit;
 280          
 281          bit save_bit;
 282          bit auto_bit;
 283          
 284          bit key_find_bit;
 285          bit temp_set_bit;
 286          bit ss_bit;
 287          
 288          bit hot_bit;
 289          
 290          bit power_bit;
 291          bit fan_bit;
 292          bit fan_bit2;
 293          bit fan_bit3;
 294          
 295           /*
 296          bit pwm2_bit;
 297          bit pwm3_bit;
 298          bit pwm4_bit;
 299          bit pwm5_bit; */
 300          
 301          bit  PWMOUT;
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 6   

 302          
 303          bit hot_fan_bit;
 304          
 305          bit fan_close_bit;
 306          bit fan_close_ok;
 307          bit tb_bit;
 308          
 309          
 310          
 311          //****************************************************************************
 312          //      MF52E 10K at 25, B = 3950, ADC = 12 bits
 313          
 314          uint code temp_table[]={
 315          282     ,//0
 316          291     ,//1
 317          300     ,//2
 318          309     ,//3
 319          318     ,//4
 320          327     ,//5
 321          337     ,//6
 322          346     ,//7
 323          356     ,//8
 324          366     ,//9
 325          375     ,//10
 326          385     ,//11
 327          395     ,//12
 328          404     ,//13
 329          414     ,//14
 330          424     ,//15
 331          434     ,//16
 332          444     ,//17
 333          454     ,//18
 334          463     ,//19
 335          473     ,//20
 336          483     ,//21
 337          493     ,//22
 338          502     ,//23
 339          512     ,//24
 340          522     ,//25
 341          531     ,//26
 342          541     ,//27
 343          550     ,//28
 344          559     ,//29
 345          568     ,//30
 346          578     ,//31
 347          587     ,//32
 348          596     ,//33
 349          604     ,//34
 350          613     ,//35
 351          622     ,//36
 352          630     ,//37
 353          639     ,//38
 354          647     ,//39
 355          655     ,//40
 356          663     ,//41
 357          671     ,//42
 358          679     ,//43
 359          687     ,//44
 360          694     ,//45
 361          702     ,//46
 362          709     ,//47
 363          716     ,//48
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 7   

 364          723     ,//49
 365          730     ,//50
 366          737     ,//51
 367          743     ,//52
 368          750     ,//53
 369          756     ,//54
 370          763     ,//55
 371          769     ,//56
 372          775     ,//57
 373          781     ,//58
 374          786     ,//59
 375          792     ,//60
 376          797     ,//61
 377          803     ,//62
 378          808     ,//63
 379          813     ,//64
 380          818     ,//65
 381          823     ,//66
 382          828     ,//67
 383          833     ,//68
 384          837     ,//69
 385          842     ,//70
 386          846     ,//71
 387          850     ,//72
 388          854     ,//73
 389          858     ,//74
 390          862     ,//75
 391          866     ,//76
 392          870     ,//77
 393          874     ,//78
 394          877     ,//79
 395          881     ,//80
 396          884     ,//81
 397          888     ,//82
 398          891     ,//83
 399          894     ,//84
 400          897     ,//85
 401          900     ,//86
 402          903     ,//87
 403          906     ,//88
 404          909     ,//89
 405          911     ,//90
 406          914     ,//91
 407          917     ,//92
 408          919     ,//93
 409          921     ,//94
 410          924     ,//95
 411          926     ,//96
 412          928     ,//97
 413          931     ,//98
 414          933     ,//99
 415          935     ,//100
 416          937     ,//101
 417          939     ,//102
 418          941     ,//103
 419          943     ,//104
 420          945     ,//105
 421          946     ,//106
 422          948     ,//107
 423          950     ,//108
 424          952     ,//109
 425          953     ,//110
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 8   

 426          955     ,//111
 427          956     ,//112
 428          958     ,//113
 429          959     ,//114
 430          961     ,//115
 431          962     ,//116
 432          964     ,//117
 433          965     ,//118
 434          966     ,//119
 435          967     //120
 436          };
 437                   
 438          //_________________________________________________________________________
 439          
 440            /*
 441          
 442          
 443          // 配置并启动 PWM，fr-频率，dc-占空比 
 444          void ConfigPWM(unsigned int fr, unsigned char dc){
 445              unsigned int high, low;
 446             
 447              PeriodCnt = (11059200/12) / fr; //计算一个周期所需的计数值   9216
 448              high = (PeriodCnt*dc) / 100; //计算高电平所需的计数值
 449              low = PeriodCnt - high; //计算低电平所需的计数值
 450              high = 65536 - high + 12; //计算高电平的重载值并补偿中断延时
 451              low = 65536 - low + 12;//计算低电平的重载值并补偿中断延时
 452             
 453              HighRH = (unsigned char)(high>>8); //高电平重载值拆分为高低字节
 454              HighRL = (unsigned char)high;
 455              LowRH = (unsigned char)(low>>8); //低电平重载值拆分为高低字节
 456              LowRL = (unsigned char)low;
 457             
 458              TMOD &= 0xF0; //清零 T0 的控制位
 459              TMOD |= 0x01; //配置 T0 为模式 1
 460              TH0 = HighRH; //加载 T0 重载值
 461              TL0 = HighRL;
 462              ET0 = 1; //使能 T0 中断
 463              TR0 = 1; //启动 T0
 464              PWMOUT = 1; //输出高电平
 465          }
 466          
 467          
 468          
 469          
 470          
 471          // 占空比调整函数，频率不变只调整占空比 
 472          void AdjustDutyCycle(uchar dc){
 473              unsigned int high, low;
 474          
 475                  if(dc>=100) dc=99;
 476                  else if(dc==0)  dc=1;
 477          
 478                  
 479              high = (PeriodCnt*dc) / 100; //计算高电平所需的计数值
 480              low = PeriodCnt - high; //计算低电平所需的计数值
 481              high = 65536 - high + 12; //计算高电平的重载值并补偿中断延时
 482              low = 65536 - low + 12;//计算低电平的重载值并补偿中断延时
 483          
 484              
 485             
 486              HighRH = (unsigned char)(high>>8); //高电平重载值拆分为高低字节
 487              HighRL = (unsigned char)high;
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 9   

 488              LowRH = (unsigned char)(low>>8); //低电平重载值拆分为高低字节
 489              LowRL = (unsigned char)low;
 490          }
 491          
 492          
 493          
 494          
 495          // 关闭 PWM 
 496          void ClosePWM(void){
 497              TR0 = 0; //停止定时器
 498              ET0 = 0; //禁止中断
 499              PWMOUT = 1; //输出高电平
 500                  
 501          }
 502          
 503            */
 504          
 505          
 506          //*******************************************************************************
 507          
 508           /*
 509          uchar ID_read_ok(void)
 510          {
 511           uchar i;
 512           cptr = ID_ADDR_ROM;         //从程序区读取ID号
 513              for (i=0; i<7; i++)         //读7个字节
 514              {
 515                 ID_old[i]= *cptr++;      
 516              }
 517            //ID数据 以下4种算法  +15  *5  /4  <<7 
 518            ID_old[0]=((ID_old[0]+15)*5/4)<<7;    
 519            ID_old[1]=((ID_old[1]+15)*5/4)<<7;
 520            ID_old[2]=((ID_old[2]+15)*5/4)<<7;
 521            ID_old[3]=((ID_old[3]+15)*5/4)<<7;
 522            ID_old[4]=((ID_old[4]+15)*5/4)<<7;
 523            ID_old[5]=((ID_old[5]+15)*5/4)<<7;
 524            ID_old[6]=((ID_old[6]+15)*5/4)<<7;
 525          
 526           cptr = 0x5f00;         //从程序区读取加密ID号  地址为0x5f00
 527              for (i=0; i<7; i++)         //读7个字节
 528              {
 529                 ID_new[i]= *cptr++;     
 530              } 
 531          
 532          
 533           for (i=0; i<7; i++){
 534                                        if(ID_old[i]!=ID_new[i])  return 1;  //比对数据不正确
 535          
 536                               }
 537           return 0;       //比对数据正确
 538          
 539          }
 540                          */
 541          
 542          /********************  计算温度 ***********************************************/
 543          // 计算结果: 0对应-40.0度, 400对应0度, 625对应25.0度, 最大1600对应120.0度. 
 544          // 为了通用, ADC输入为12bit的ADC值.
 545          // 电路和软件算法设计: Coody
 546          /**********************************************/
 547                           
 548          //#define               D_SCALE         10              //结果放大倍数, 放大10倍就是保留一位小数
 549          uint get_temperature(uint adc)
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 10  

 550          {
 551   1              uint    code *p;
 552   1              uint    i;
 553   1              uchar   j,k,min,max;
 554   1              
 555   1              //adc = 4096 - adc;     //Rt接地
 556   1              p = temp_table;
 557   1              //if(adc < p[0])                return (0xfffe);
 558   1              //if(adc > p[160])      return (0xffff);
 559   1                      
 560   1              min = 0;                //0度
 561   1              max = 120;              //120度
 562   1      
 563   1              for(j=0; j<5; j++)      //对分查表
 564   1              {
 565   2                      k = min / 2 + max / 2;
 566   2                      if(adc <= p[k]) max = k;
 567   2                      else                    min = k;
 568   2              }
 569   1                       if(adc == p[min])      i = min;
 570   1              else if(adc == p[max])  i = max;
 571   1              else    // min < temp < max
 572   1              {
 573   2                      while(min <= max)
 574   2                      {
 575   3                              min++;
 576   3                              if(adc == p[min])       {i = min;       break;}
 577   3                              else if(adc < p[min])
 578   3                              {
 579   4                                      min--;
 580   4                                      //i = p[min];   //min
 581   4                                      //j = (adc - i) * D_SCALE / (p[min+1] - i);
 582   4                                      i = min;
 583   4                                      //i *= D_SCALE;
 584   4                                      //i += j;
 585   4                                      break;
 586   4                              }
 587   3                      }
 588   2              }
 589   1              return i;
 590   1      }
 591                   
 592          
 593          //************************************************************************
 594          
 595          void Delay1ms(unsigned int dd)          //@11.0592MHz
 596          {
 597   1              unsigned char i, j;
 598   1        while(dd){
 599   2                          _nop_();
 600   2                          _nop_();
 601   2                          _nop_();
 602   2                       i = 11;
 603   2                       j = 190;
 604   2                       do
 605   2                         {
 606   3                              while (--j);
 607   3                         } while (--i);
 608   2      
 609   2                           WDT_CONTR=0X34;
 610   2                               dd--;
 611   2                  }
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 11  

 612   1      }
 613          
 614          
 615          //**************************************************************************
 616          /*
 617          
 618          int PID(int Set_value,int Real_value) //标准PID温度控制算法
 619          {
 620                  float uk ,uk1 ,duk;
 621                  int pid_out,e,e1 ,e2;
 622                  e=Set_value-Real_value;//误差量
 623                  duk=Kp*(e-e1)+Ki*e+Kd*(e-2*e1+e2);  //+Kd*(e-2e1+e2)
 624                  uk=uk1+duk;
 625                  pid_out=(int)uk;
 626                  uk1=uk;
 627                  e2=e1;
 628                  e1=e;
 629                  if(pid_out>1000) //1000
 630                  {
 631                          pid_out=990;//        990
 632                  }
 633                  else if(pid_out<10)         //10
 634                  {
 635                          pid_out=10;                //10
 636                  }
 637                  //outp=pid_out;
 638          
 639                  return(pid_out);
 640                         
 641          }
 642                  */
 643          
 644          //*****************************************************************************
 645          
 646          
 647          void UartInit(void)             //9600bps@11.0592MHz
 648          {
 649   1              SCON = 0x50;            //8位数据,可变波特率 串口1
 650   1      
 651   1              //S3CON = 0x10;         //8位数据,可变波特率
 652   1              //S3CON &= 0xBF;                //串口3选择定时器2为波特率发生器
 653   1      
 654   1              //S4CON = 0x10;         //8位数据,可变波特率
 655   1              //S4CON &= 0xBF;                //串口4选择定时器2为波特率发生器
 656   1      
 657   1          AUXR |= 0x01;               //串口1选择定时器2为波特率发生器
 658   1              AUXR |= 0x04;           //定时器2时钟为Fosc,即1T
 659   1              T2L = 0xE0;             //设定定时初值
 660   1              T2H = 0xFE;             //设定定时初值
 661   1              AUXR |= 0x10;           //启动定时器2
 662   1              RI=0;
 663   1              TI=0;
 664   1      
 665   1              //S3CON &= ~S3RI;
 666   1              //S4CON &= ~S4RI;
 667   1              //IE2 = 0x08;     //打开串口3中断
 668   1              //ES=1;
 669   1      }
 670                            
 671          
 672          void Timer0Init(void)           //10ms@11.0592MHz
 673          {
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 12  

 674   1              AUXR &= 0x7F;           //定时器时钟12T模式
 675   1              TMOD &= 0xF0;           //设置定时器模式
 676   1              TMOD |= 0x01;           //设置定时器模式
 677   1              TL0 = 0x00;             //设置定时初值
 678   1              TH0 = 0xDC;             //设置定时初值
 679   1              TF0 = 0;                //清除TF0标志
 680   1              TR0 = 0;                //定时器0开始计时
 681   1              ET0=0;
 682   1      }
 683          
 684          
 685          
 686          void Timer1Init(void)   
 687          {
 688   1              TMOD &= 0x0f;           //设置计数器模式
 689   1              TMOD |= 0x50;           //设置计数器模式
 690   1              TL1 = 0;                //设置定时初值
 691   1              TH1 = 0;                //设置定时重载值
 692   1          ET1=0;
 693   1              //TR1 = 1;              //定时器1开始计数
 694   1      }
 695          
 696          
 697          
 698          void Timer3Init(void)           //50毫秒@11.0592MHz
 699          {
 700   1              T4T3M &= 0xFD;          //定时器时钟12T模式
 701   1              T3L = 0x00;             //设置定时初值
 702   1              T3H = 0x4C;             //设置定时初值
 703   1              T4T3M |= 0x08;          //定时器3开始计时
 704   1              IE2 |= 0x20;       //开定时器3中断
 705   1      }
 706          
 707          
 708          
 709          
 710          
 711          
 712          /*----------------------------------------------------------------------------
 713          关闭IAP
 714          ----------------------------*/
 715          void IapIdle()
 716          {
 717   1          IAP_CONTR = 0;                  //关闭IAP功能
 718   1          IAP_CMD = 0;                    //清除命令寄存器
 719   1          IAP_TRIG = 0;                   //清除触发寄存器
 720   1          IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
 721   1          IAP_ADDRL = 0;
 722   1      }
 723          
 724          /*----------------------------
 725          从ISP/IAP/EEPROM区域读取一字节
 726          ----------------------------*/
 727          uchar IapReadByte(uint addr)
 728          {
 729   1          uchar dat;                       //数据缓冲区
 730   1      
 731   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 732   1          IAP_CMD = CMD_READ;             //设置IAP命令
 733   1          IAP_ADDRL = addr;               //设置IAP低地址
 734   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 735   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 13  

 736   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 737   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 738   1          dat = IAP_DATA;                 //读ISP/IAP/EEPROM数据
 739   1          IapIdle();                      //关闭IAP功能
 740   1      
 741   1          return dat;                     //返回
 742   1      }
 743          
 744          /*----------------------------
 745          写一字节数据到ISP/IAP/EEPROM区域
 746          ----------------------------*/
 747          void IapProgramByte(uint addr, uchar dat)
 748          {
 749   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 750   1          IAP_CMD = CMD_PROGRAM;          //设置IAP命令
 751   1          IAP_ADDRL = addr;               //设置IAP低地址
 752   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 753   1          IAP_DATA = dat;                 //写ISP/IAP/EEPROM数据
 754   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 755   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 756   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 757   1          IapIdle();
 758   1      }
 759          
 760          /*----------------------------
 761          扇区擦除
 762          ----------------------------*/
 763          void IapEraseSector(uint addr)
 764          {
 765   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 766   1          IAP_CMD = CMD_ERASE;            //设置IAP命令
 767   1          IAP_ADDRL = addr;               //设置IAP低地址
 768   1          IAP_ADDRH = addr >> 8;          //设置IAP高地址
 769   1          IAP_TRIG = 0x5a;                //写触发命令(0x5a)
 770   1          IAP_TRIG = 0xa5;                //写触发命令(0xa5)
 771   1          _nop_();                        //等待ISP/IAP/EEPROM操作完成
 772   1          IapIdle();
 773   1      }
 774          
 775          //******************************************************************
 776                  
 777          void save_mode_num(void)   //保存模式数值
 778          {
 779   1       uint addr;
 780   1       
 781   1       addr=0x0000;
 782   1       EA=0;
 783   1       IapEraseSector(addr);    //扇区擦除
 784   1      
 785   1       IapProgramByte(addr,mode_num); 
 786   1       
 787   1                     
 788   1       EA=1;
 789   1      }
 790          
 791          
 792          void fan_close_save(void)
 793          {
 794   1       uint addr;
 795   1       
 796   1       addr=0x1000;
 797   1       EA=0;
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 14  

 798   1       IapEraseSector(addr);    //扇区擦除
 799   1      
 800   1       IapProgramByte(addr,fan_close_cnt); 
 801   1       
 802   1                     
 803   1       EA=1;
 804   1      
 805   1      }
 806          
 807          
 808          void fan_close_read(void) 
 809          {
 810   1       uint addr;
 811   1       
 812   1       addr=0x1000;
 813   1       EA=0;
 814   1       fan_close_cnt=IapReadByte(addr);
 815   1       EA=1;
 816   1                                                                                                                                               //出厂时间120秒和15秒两种
 817   1       if((fan_close_cnt<1)||(fan_close_cnt>250))       fan_close_cnt=15;      //延时关闭风机时间
 818   1      }
 819          
 820          
 821          
 822          //**********************************************************
 823          void  read_mode_wr_data(void) //读取每个模式中的参数
 824          {
 825   1       fenduan_num=mode_wr[0]; //分段
 826   1       tb_num=mode_wr[1];         //同步
 827   1       fan_num=mode_wr[2];    //风力
 828   1       hot_num=mode_wr[3];    //同步
 829   1       temp_set=mode_wr[4];   //温度
 830   1      
 831   1       if((fenduan_num==0)||(fenduan_num>7))  fenduan_num=1;
 832   1       if(tb_num>1)       tb_num=0; //同步只有0和1，0没有同步，1为同步
 833   1       if(fan_num>6)      fan_num=0;
 834   1       if(hot_num>100)    hot_num=50;
 835   1       if(temp_set>220)       temp_set=80;
 836   1      
 837   1      }
 838          
 839          
 840          void  save_mode_wr(void)
 841          {
 842   1       uchar n;
 843   1       uint addr;
 844   1      
 845   1       mode_wr[0]=fenduan_num; //分段
 846   1       mode_wr[1]=tb_num;          //同步
 847   1       mode_wr[2]=fan_num;    //风力
 848   1       mode_wr[3]=hot_num;    //同步
 849   1       mode_wr[4]=temp_set;   //温度
 850   1      
 851   1       if(mode_num==1) 
 852   1         {
 853   2          addr=0x0200;
 854   2              EA=0;
 855   2              IapEraseSector(addr);    //扇区擦除
 856   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 857   2              EA=1;
 858   2         }
 859   1      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 15  

 860   1       else if(mode_num==2) 
 861   1         {
 862   2          addr=0x0400;
 863   2              EA=0;
 864   2              IapEraseSector(addr);    //扇区擦除
 865   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 866   2              EA=1;
 867   2         }
 868   1      
 869   1       else if(mode_num==3) 
 870   1         {
 871   2          addr=0x0600;
 872   2              EA=0;
 873   2              IapEraseSector(addr);    //扇区擦除
 874   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 875   2              EA=1;
 876   2         }
 877   1      
 878   1       else if(mode_num==4) 
 879   1         {
 880   2          addr=0x0800;
 881   2              EA=0;
 882   2              IapEraseSector(addr);    //扇区擦除
 883   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 884   2              EA=1;
 885   2         }
 886   1      
 887   1       else if(mode_num==5) 
 888   1         {
 889   2          addr=0x0a00;
 890   2              EA=0;
 891   2              IapEraseSector(addr);    //扇区擦除
 892   2          for(n=0;n<5;n++) {IapProgramByte(addr,mode_wr[n]);  addr++;}
 893   2              EA=1;
 894   2         }
 895   1      }
 896          
 897          
 898          void read_mode(void)
 899          {
 900   1       uint addr;
 901   1       EA=0;
 902   1       addr=0x0000;
 903   1       mode_num=IapReadByte(addr);
 904   1       
 905   1       EA=1;
 906   1      
 907   1      
 908   1       }
 909          
 910            
 911          void read_data(void)
 912          {
 913   1       uint addr;
 914   1       uchar n;
 915   1      
 916   1       if((mode_num==0)||(mode_num>5)) {mode_num=1;}
 917   1      
 918   1       if(mode_num==1) 
 919   1         {
 920   2              EA=0;
 921   2              addr=0x0200;
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 16  

 922   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 923   2              EA=1;
 924   2         }
 925   1      
 926   1       else if(mode_num==2) 
 927   1         {
 928   2              EA=0;
 929   2              addr=0x0400;
 930   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 931   2              EA=1;
 932   2         }
 933   1      
 934   1       else if(mode_num==3) 
 935   1         {
 936   2              EA=0;
 937   2              addr=0x0600;
 938   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 939   2              EA=1;
 940   2         }
 941   1      
 942   1       else if(mode_num==4) 
 943   1         {
 944   2              EA=0;
 945   2              addr=0x0800;
 946   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 947   2              EA=1;
 948   2         }
 949   1      
 950   1       else if(mode_num==5) 
 951   1         {
 952   2              EA=0;
 953   2              addr=0x0a00;
 954   2          for(n=0;n<5;n++) {mode_wr[n]=IapReadByte(addr);     addr++;}
 955   2              EA=1;
 956   2         }
 957   1      
 958   1       read_mode_wr_data();  //加载模式对应的参数
 959   1       
 960   1      
 961   1      
 962   1      
 963   1      }
 964          
 965                  
 966          
 967          
 968          
 969          //__________________________________________________________________________
 970          
 971          
 972          //***********************************************************************
 973          
 974          void InitADC(void)
 975          {
 976   1          P1ASF = B0011_1111;                   //设置P1.0~P1.5口为AD口
 977   1          ADC_RES = 0;                    //清除结果寄存器
 978   1          ADC_RESL=0;
 979   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL;
 980   1         
 981   1      }
 982          
 983          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 17  

 984          //----------------------------
 985          //读取ADC结果
 986          //----------------------------
 987          uint GetADCResult(uchar ch)      //ch为输入模拟量通道号0~7
 988          {
 989   1       uint dd=0;
 990   1      
 991   1          ADC_CONTR = ADC_POWER | ADC_SPEEDL | ch | ADC_START;
 992   1          _nop_();                        //等待4个NOP
 993   1          _nop_();
 994   1          _nop_();
 995   1          _nop_();
 996   1          while (!(ADC_CONTR & ADC_FLAG));//等待ADC转换完成
 997   1          ADC_CONTR &= ~ADC_FLAG;         //Close ADC
 998   1      
 999   1          dd= ADC_RES;                 //返回ADC结果
1000   1          dd=dd<<2;
1001   1          dd=dd|ADC_RESL;
1002   1              return dd;
1003   1      }
1004           
1005          
1006          
1007          uint Temperature_LPF(uchar ch)
1008          {
1009   1       uint a;
1010   1       uchar i,j,k;
1011   1       for(i=0;i<=6;i++)
1012   1        {
1013   2          temp[i]= GetADCResult(ch); //采集7个数据.
1014   2          Delay1ms(5);
1015   2        }
1016   1       for(j=0;j<=6;j++)
1017   1        {                      //按从小到大排序
1018   2          for(k=j;k<=6;k++)
1019   2               {
1020   3             if(temp[j]>=temp[k])
1021   3                   {
1022   4                 a=temp[j];
1023   4                 temp[j]=temp[k];
1024   4                 temp[k]=a;
1025   4                }
1026   3            }
1027   2         }
1028   1       temp[0]=temp[6]=0;
1029   1      //去掉最大最小值
1030   1      return (temp[1]+temp[2]+temp[3]+temp[4]+temp[5])/5; //求平均值
1031   1      
1032   1      }
1033          
1034          
1035          
1036          /*
1037          
1038          float Get_Tempture(uint adc)
1039          {
1040                  float RV,RT,Tmp;
1041                  RV=BaseVol/1024.0*(float)adc;//ADC为10位ADC,求出NTC电压:RV=ADCValu/1024*BaseVoltag
1042                  RT=RV*10/RV;//(BaseVol-RV);//求出当前温度阻值 (BaseVoltage-RV)/R16=RV/RT;
1043                  Tmp=1/(1/TN+(log(RT/RN)/B))-273.15;//%RT = RN exp*B(1/T-1/TN)%
1044                   return Tmp;
1045          }
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 18  

1046            */
1047          
1048          
1049          
1050          
1051          
1052          /**************************************************************************
1053           - 功能描述：51单片机的串口发送字节的函数
1054           - 隶属模块：STC51串口操作
1055           - 函数属性：外部，使用户使用
1056           - 参数说明：mydata:要发送的一个字节
1057           - 返回说明：无
1058           - 注：发送一个字节，是串口发送的基础操作
1059           **************************************************************************/
1060           
1061          void UART_Send_Byte(unsigned char mydata)       
1062          {
1063   1      
1064   1       TI=0;         //清除TI位
1065   1        
1066   1       SBUF=mydata;
1067   1       while(TI==0);
1068   1       TI=0;          //清除TI位
1069   1       
1070   1       
1071   1      }
1072          
1073           
1074          
1075          /**************************************************************************
1076           - 功能描述：51单片机的串口发送字符串
1077           - 隶属模块：STC51串口操作
1078           - 函数属性：外部，使用户使用
1079           - 参数说明：s:指向字符串的指针
1080           - 返回说明：无
1081           **************************************************************************/
1082           
1083          void UART_Send_Str(uchar *s)
1084          {                                
1085   1       uchar i=0;
1086   1       while(s[i]!=0)
1087   1       {
1088   2          
1089   2              UART_Send_Byte(s[i]);
1090   2              i++;
1091   2       }
1092   1      
1093   1       UART_Send_Byte(0xFF);
1094   1       UART_Send_Byte(0xFF);
1095   1       UART_Send_Byte(0xFF);
1096   1      
1097   1      // for(i=0;i<20;i++) buff[i]=0;
1098   1       
1099   1       
1100   1      }
1101          
1102          
1103          //*********************************************************************
1104          
1105          
1106          void Delay50us(void)            //@11.0592MHz
1107          {
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 19  

1108   1              unsigned char i, j;
1109   1         
1110   1              _nop_();
1111   1              i = 1;
1112   1              j = 134;
1113   1              do
1114   1              {
1115   2                      while (--j);
1116   2              } while (--i);
1117   1       
1118   1      }
1119                             
1120          
1121          
1122                                                            
1123                        
1124          
1125          /******************************************
1126          函数：写一字节函数
1127          参数：dat---写入的一字节数据
1128          返回值：无
1129          ******************************************/
1130          void TM1722_Write_Byte(unsigned char dat)
1131          {
1132   1        unsigned char i;
1133   1               
1134   1        Delay50us(); //用于片选信号的延时
1135   1        TM1722_STB=0;     //有效的片选信号
1136   1        for(i=0;i<8;i++)
1137   1        {
1138   2         TM1722_CLK=0;
1139   2         TM1722_DIO=dat&0x01;
1140   2         TM1722_CLK=1;    //时钟上升沿，送入一位数据
1141   2         dat>>=1;      
1142   2        }
1143   1        Delay50us();   //用于片选信号的延时
1144   1      }
1145          
1146          
1147          
1148          
1149          
1150          
1151          /******************************************
1152          函数：写一位数码管函数
1153          参数：num_addr---数码管位，num---显示数字数据
1154          返回值：无
1155          ******************************************/
1156          void TM1722_Write_Word(uchar num_addr,uchar num)
1157          {
1158   1        uchar temp1,temp2;
1159   1        uchar addr1;
1160   1        uchar addr2;
1161   1      
1162   1        if(num_addr==1)       {addr1=0xcb;  addr2=0xca;  lcd_0bh=lcd_0bh&B1111_0000; lcd_0bh=temp1=lcd_0bh|(Tab[
             -num]&0xf0)>>4;  lcd_0ah=lcd_0ah&B1111_0000; lcd_0ah=temp2=lcd_0ah|(Tab[num]&0x0f);}
1163   1        else if(num_addr==2)  {addr1=0xc7;  addr2=0xc7;  lcd_07h=lcd_07h&B0000_1000; lcd_07h=temp2=lcd_07h|Tab[n
             -um];}
1164   1        else if(num_addr==3)  {addr1=0xc6;  addr2=0xc6;  lcd_06h=lcd_06h&B0000_1000; lcd_06h=temp2=lcd_06h|Tab[n
             -um];}
1165   1       
1166   1      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 20  

1167   1      
1168   1        TM1722_STB=1;            //端口配置初始化
1169   1        TM1722_CLK=1;
1170   1        TM1722_DIO=1;
1171   1        TM1722_Write_Byte(0x00); //工作模式
1172   1        TM1722_STB=1;
1173   1        TM1722_Write_Byte(0x44);   //固定地址模式
1174   1        TM1722_STB=1;
1175   1      
1176   1        if(num_addr!=1) goto  next_num1;
1177   1         
1178   1        TM1722_Write_Byte(addr1);//显示寄存器的00H单元开始
1179   1        TM1722_Write_Byte(temp1);     //给显示寄存器送数据，
1180   1        TM1722_STB=1;  
1181   1      
1182   1        next_num1: nop;
1183   1      
1184   1        TM1722_Write_Byte(addr2);//显示寄存器的00H单元开始
1185   1        TM1722_Write_Byte(temp2);     //给显示寄存器送数据，
1186   1        TM1722_STB=1;
1187   1      
1188   1        TM1722_Write_Byte(0x93); //显示开
1189   1        TM1722_STB=1;
1190   1        
1191   1      }   
1192           
1193          
1194          void fan_dis(uchar num)   //风量条显示
1195          {
1196   1        if(num==0)       {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0000_0000; }
1197   1        else if(num==1)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B0100_0000; }
1198   1        else if(num==2)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_0000; }
1199   1        else if(num==3)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1000; }
1200   1        else if(num==4)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1100; }
1201   1        else if(num==5)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1110; }
1202   1        else if(num==6)  {lcd_0fh=lcd_0fh&B0011_0000;  lcd_0fh=lcd_0fh|B1100_1111; }
1203   1      
1204   1        TM1722_STB=1;            //端口配置初始化
1205   1        TM1722_CLK=1;
1206   1        TM1722_DIO=1;
1207   1        TM1722_Write_Byte(0x00); //工作模式
1208   1        TM1722_STB=1;
1209   1        TM1722_Write_Byte(0x44);   //固定地址模式
1210   1        TM1722_STB=1;
1211   1       
1212   1      
1213   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1214   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1215   1        TM1722_STB=1;
1216   1      
1217   1        TM1722_Write_Byte(0x93); //显示开
1218   1        TM1722_STB=1;
1219   1        
1220   1      }   
1221          
1222          
1223          
1224          
1225          
1226          
1227          
1228          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 21  

1229          
1230          void lcd_clear(uchar dat)  //清显示缓存
1231          {
1232   1      
1233   1        lcd_03h=dat;
1234   1        lcd_06h=dat;
1235   1        lcd_07h=dat;
1236   1        lcd_0ah=dat;
1237   1        lcd_0bh=dat;
1238   1        lcd_0eh=dat;
1239   1        lcd_0fh=dat;
1240   1      
1241   1        TM1722_STB=1;            //端口配置初始化
1242   1        TM1722_CLK=1;
1243   1        TM1722_DIO=1;
1244   1        TM1722_Write_Byte(0x00); //工作模式
1245   1        TM1722_STB=1;
1246   1        TM1722_Write_Byte(0x44);   //固定地址模式
1247   1        TM1722_STB=1;
1248   1      
1249   1                                                              
1250   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1251   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1252   1        TM1722_STB=1;
1253   1      
1254   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1255   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1256   1        TM1722_STB=1;
1257   1      
1258   1        TM1722_Write_Byte(0xc7);         //显示寄存器的00H单元开始
1259   1        TM1722_Write_Byte(lcd_07h);     //给显示寄存器送数据，
1260   1        TM1722_STB=1;
1261   1      
1262   1        TM1722_Write_Byte(0xca);         //显示寄存器的00H单元开始
1263   1        TM1722_Write_Byte(lcd_0ah);     //给显示寄存器送数据，
1264   1        TM1722_STB=1;
1265   1      
1266   1      
1267   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1268   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1269   1        TM1722_STB=1;
1270   1      
1271   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1272   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1273   1        TM1722_STB=1;
1274   1      
1275   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1276   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1277   1        TM1722_STB=1;
1278   1      
1279   1        TM1722_Write_Byte(0x93); //显示开
1280   1        TM1722_STB=1;
1281   1      
1282   1      }
1283          
1284          
1285          
1286          void  dis1(bit sss,uint ss)  //sss=0,不显示   sss=1 显示出来  
1287          {
1288   1       uchar a1,a2,a3;
1289   1       if(sss)
1290   1         {
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 22  

1291   2          a1=ss%1000/100;
1292   2          a2=ss%100/10;
1293   2          a3=ss%10;
1294   2      
1295   2               if(a1==0) TM1722_Write_Word(1,16);
1296   2           else      TM1722_Write_Word(1,a1);
1297   2      
1298   2               if((a1==0)&&(a2==0)) TM1722_Write_Word(2,16);
1299   2           else                 TM1722_Write_Word(2,a2); 
1300   2                
1301   2           TM1722_Write_Word(3,a3); 
1302   2          
1303   2         }
1304   1       else
1305   1        {
1306   2           TM1722_Write_Word(1,16);  
1307   2           TM1722_Write_Word(2,16);  
1308   2           TM1722_Write_Word(3,16); 
1309   2           
1310   2         }
1311   1      
1312   1      }
1313          
1314          
1315          
1316          
1317          
1318          void temp_dis(bit on_off) //1--显示，0--不显示   点亮 S10 
1319          {
1320   1        if(on_off) {lcd_03h=lcd_03h|B0100_0000;       }
1321   1        else           {lcd_03h=lcd_03h&B1011_1111;   }
1322   1      
1323   1        TM1722_STB=1;            //端口配置初始化
1324   1        TM1722_CLK=1;
1325   1        TM1722_DIO=1;
1326   1        TM1722_Write_Byte(0x00); //工作模式
1327   1        TM1722_STB=1;
1328   1        TM1722_Write_Byte(0x44);   //固定地址模式
1329   1        TM1722_STB=1;
1330   1      
1331   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1332   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1333   1        TM1722_STB=1;
1334   1      
1335   1      
1336   1        TM1722_Write_Byte(0x93); //显示开
1337   1        TM1722_STB=1;
1338   1      }
1339          
1340          
1341          
1342          void hot_dis(bit on_off) //1--显示，0--不显示    点亮S1
1343          {
1344   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_1000;       }
1345   1        else           {lcd_0eh=lcd_0eh&B1111_0111;   }
1346   1      
1347   1        TM1722_STB=1;            //端口配置初始化
1348   1        TM1722_CLK=1;
1349   1        TM1722_DIO=1;
1350   1        TM1722_Write_Byte(0x00); //工作模式
1351   1        TM1722_STB=1;
1352   1        TM1722_Write_Byte(0x44);   //固定地址模式
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 23  

1353   1        TM1722_STB=1;
1354   1      
1355   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1356   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1357   1        TM1722_STB=1;
1358   1      
1359   1      
1360   1        TM1722_Write_Byte(0x93); //显示开
1361   1        TM1722_STB=1;
1362   1      }
1363          
1364          
1365          
1366          void hot1_dis(bit on_off) //1--显示，0--不显示   点亮S2
1367          {
1368   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0100;       }
1369   1        else           {lcd_0eh=lcd_0eh&B1111_1011;   }
1370   1      
1371   1        TM1722_STB=1;            //端口配置初始化
1372   1        TM1722_CLK=1;
1373   1        TM1722_DIO=1;
1374   1        TM1722_Write_Byte(0x00); //工作模式
1375   1        TM1722_STB=1;
1376   1        TM1722_Write_Byte(0x44);   //固定地址模式
1377   1        TM1722_STB=1;
1378   1      
1379   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1380   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1381   1        TM1722_STB=1;
1382   1      
1383   1      
1384   1        TM1722_Write_Byte(0x93); //显示开
1385   1        TM1722_STB=1;
1386   1      }
1387          
1388          
1389          
1390          
1391          
1392          void hot2_dis(bit on_off) //1--显示，0--不显示   点亮S3
1393          {
1394   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0010;       }
1395   1        else           {lcd_0eh=lcd_0eh&B1111_1101;   }
1396   1      
1397   1        TM1722_STB=1;            //端口配置初始化
1398   1        TM1722_CLK=1;
1399   1        TM1722_DIO=1;
1400   1        TM1722_Write_Byte(0x00); //工作模式
1401   1        TM1722_STB=1;
1402   1        TM1722_Write_Byte(0x44);   //固定地址模式
1403   1        TM1722_STB=1;
1404   1      
1405   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1406   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1407   1        TM1722_STB=1;
1408   1      
1409   1      
1410   1        TM1722_Write_Byte(0x93); //显示开
1411   1        TM1722_STB=1;
1412   1      }
1413             
1414          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 24  

1415          
1416          
1417          void hot3_dis(bit on_off) //1--显示，0--不显示   点亮S4
1418          {
1419   1        if(on_off) {lcd_0eh=lcd_0eh|B0000_0001;       }
1420   1        else           {lcd_0eh=lcd_0eh&B1111_1110;   }
1421   1      
1422   1        TM1722_STB=1;            //端口配置初始化
1423   1        TM1722_CLK=1;
1424   1        TM1722_DIO=1;
1425   1        TM1722_Write_Byte(0x00); //工作模式
1426   1        TM1722_STB=1;
1427   1        TM1722_Write_Byte(0x44);   //固定地址模式
1428   1        TM1722_STB=1;
1429   1      
1430   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1431   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1432   1        TM1722_STB=1;
1433   1      
1434   1      
1435   1        TM1722_Write_Byte(0x93); //显示开
1436   1        TM1722_STB=1;
1437   1      }
1438          
1439          
1440          
1441          
1442          
1443          void H1_dis(bit on_off) //1--显示，0--不显示     点亮 数字1  H1
1444          {
1445   1        if(on_off) {lcd_0bh=lcd_0bh|B0100_0000;       }
1446   1        else           {lcd_0bh=lcd_0bh&B1011_1111;   }
1447   1      
1448   1        TM1722_STB=1;            //端口配置初始化
1449   1        TM1722_CLK=1;
1450   1        TM1722_DIO=1;
1451   1        TM1722_Write_Byte(0x00); //工作模式
1452   1        TM1722_STB=1;
1453   1        TM1722_Write_Byte(0x44);   //固定地址模式
1454   1        TM1722_STB=1;
1455   1      
1456   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1457   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1458   1        TM1722_STB=1;
1459   1      
1460   1      
1461   1        TM1722_Write_Byte(0x93); //显示开
1462   1        TM1722_STB=1;
1463   1      }
1464          
1465          
1466          void H2_dis(bit on_off) //1--显示，0--不显示     点亮 数字2  H2
1467          {
1468   1        if(on_off) {lcd_0bh=lcd_0bh|B0010_0000;       }
1469   1        else           {lcd_0bh=lcd_0bh&B1101_1111;   }
1470   1      
1471   1        TM1722_STB=1;            //端口配置初始化
1472   1        TM1722_CLK=1;
1473   1        TM1722_DIO=1;
1474   1        TM1722_Write_Byte(0x00); //工作模式
1475   1        TM1722_STB=1;
1476   1        TM1722_Write_Byte(0x44);   //固定地址模式
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 25  

1477   1        TM1722_STB=1;
1478   1      
1479   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1480   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1481   1        TM1722_STB=1;
1482   1      
1483   1      
1484   1        TM1722_Write_Byte(0x93); //显示开
1485   1        TM1722_STB=1;
1486   1      }
1487          
1488          
1489          
1490          
1491          
1492          void H3_dis(bit on_off) //1--显示，0--不显示     点亮 数字3  H3
1493          {
1494   1        if(on_off) {lcd_0bh=lcd_0bh|B0001_0000;       }
1495   1        else           {lcd_0bh=lcd_0bh&B1110_1111;   }
1496   1      
1497   1        TM1722_STB=1;            //端口配置初始化
1498   1        TM1722_CLK=1;
1499   1        TM1722_DIO=1;
1500   1        TM1722_Write_Byte(0x00); //工作模式
1501   1        TM1722_STB=1;
1502   1        TM1722_Write_Byte(0x44);   //固定地址模式
1503   1        TM1722_STB=1;
1504   1      
1505   1        TM1722_Write_Byte(0xcb);         //显示寄存器的00H单元开始
1506   1        TM1722_Write_Byte(lcd_0bh);     //给显示寄存器送数据，
1507   1        TM1722_STB=1;
1508   1      
1509   1      
1510   1        TM1722_Write_Byte(0x93); //显示开
1511   1        TM1722_STB=1;
1512   1      }
1513          
1514          
1515          
1516          void tb_dis(bit on_off) //1--显示，0--不显示     点亮 S5  同步标志
1517          {
1518   1        if(on_off) {lcd_03h=lcd_03h|B0001_0000;       }
1519   1        else           {lcd_03h=lcd_03h&B1110_1111;   }
1520   1      
1521   1        TM1722_STB=1;            //端口配置初始化
1522   1        TM1722_CLK=1;
1523   1        TM1722_DIO=1;
1524   1        TM1722_Write_Byte(0x00); //工作模式
1525   1        TM1722_STB=1;
1526   1        TM1722_Write_Byte(0x44);   //固定地址模式
1527   1        TM1722_STB=1;
1528   1      
1529   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1530   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1531   1        TM1722_STB=1;
1532   1      
1533   1      
1534   1        TM1722_Write_Byte(0x93); //显示开
1535   1        TM1722_STB=1;
1536   1      }
1537          
1538          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 26  

1539          
1540          
1541          
1542          
1543          
1544          void jg_dis(bit on_off) //1--显示，0--不显示     点亮 S6  警告标志
1545          {
1546   1        if(on_off) {lcd_03h=lcd_03h|B0010_0000;       }
1547   1        else           {lcd_03h=lcd_03h&B1101_1111;   }
1548   1      
1549   1        TM1722_STB=1;            //端口配置初始化
1550   1        TM1722_CLK=1;
1551   1        TM1722_DIO=1;
1552   1        TM1722_Write_Byte(0x00); //工作模式
1553   1        TM1722_STB=1;
1554   1        TM1722_Write_Byte(0x44);   //固定地址模式
1555   1        TM1722_STB=1;
1556   1      
1557   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1558   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1559   1        TM1722_STB=1;
1560   1      
1561   1      
1562   1        TM1722_Write_Byte(0x93); //显示开
1563   1        TM1722_STB=1;
1564   1      }
1565          
1566          
1567          
1568          
1569          
1570          
1571          void mode_dis(bit on_off) //1--显示，0--不显示   点亮 S11  Mode
1572          {
1573   1        if(on_off) {lcd_03h=lcd_03h|B1000_0000;       }
1574   1        else           {lcd_03h=lcd_03h&B0111_1111;   }
1575   1      
1576   1        TM1722_STB=1;            //端口配置初始化
1577   1        TM1722_CLK=1;
1578   1        TM1722_DIO=1;
1579   1        TM1722_Write_Byte(0x00); //工作模式
1580   1        TM1722_STB=1;
1581   1        TM1722_Write_Byte(0x44);   //固定地址模式
1582   1        TM1722_STB=1;
1583   1      
1584   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1585   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1586   1        TM1722_STB=1;
1587   1      
1588   1      
1589   1        TM1722_Write_Byte(0x93); //显示开
1590   1        TM1722_STB=1;
1591   1      }
1592          
1593          
1594          
1595          
1596          
1597          
1598          
1599          
1600          void bf_dis(bit on_off) //1--显示，0--不显示     点亮 S12  % 标志
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 27  

1601          {
1602   1        if(on_off) {lcd_06h=lcd_06h|B0000_1000;       }
1603   1        else           {lcd_06h=lcd_06h&B1111_0111;   }
1604   1      
1605   1        TM1722_STB=1;            //端口配置初始化
1606   1        TM1722_CLK=1;
1607   1        TM1722_DIO=1;
1608   1        TM1722_Write_Byte(0x00); //工作模式
1609   1        TM1722_STB=1;
1610   1        TM1722_Write_Byte(0x44);   //固定地址模式
1611   1        TM1722_STB=1;
1612   1      
1613   1        TM1722_Write_Byte(0xc6);         //显示寄存器的00H单元开始
1614   1        TM1722_Write_Byte(lcd_06h);     //给显示寄存器送数据，
1615   1        TM1722_STB=1;
1616   1      
1617   1      
1618   1        TM1722_Write_Byte(0x93); //显示开
1619   1        TM1722_STB=1;
1620   1      }
1621          
1622          
1623          
1624          
1625          
1626          void set_dis(bit on_off) //1--显示，0--不显示    点亮 H4  Set 标志
1627          {
1628   1        if(on_off) {lcd_03h=lcd_03h|B0000_0100;       }
1629   1        else           {lcd_03h=lcd_03h&B1111_1011;   }
1630   1      
1631   1        TM1722_STB=1;            //端口配置初始化
1632   1        TM1722_CLK=1;
1633   1        TM1722_DIO=1;
1634   1        TM1722_Write_Byte(0x00); //工作模式
1635   1        TM1722_STB=1;
1636   1        TM1722_Write_Byte(0x44);   //固定地址模式
1637   1        TM1722_STB=1;
1638   1      
1639   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1640   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1641   1        TM1722_STB=1;
1642   1      
1643   1      
1644   1        TM1722_Write_Byte(0x93); //显示开
1645   1        TM1722_STB=1;
1646   1      }
1647          
1648          
1649          
1650          void cur_dis(bit on_off) //1--显示，0--不显示    点亮 H5  Cur 标志
1651          {
1652   1        if(on_off) {lcd_03h=lcd_03h|B0000_1000;       }
1653   1        else           {lcd_03h=lcd_03h&B1111_0111;   }
1654   1      
1655   1        TM1722_STB=1;            //端口配置初始化
1656   1        TM1722_CLK=1;
1657   1        TM1722_DIO=1;
1658   1        TM1722_Write_Byte(0x00); //工作模式
1659   1        TM1722_STB=1;
1660   1        TM1722_Write_Byte(0x44);   //固定地址模式
1661   1        TM1722_STB=1;
1662   1      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 28  

1663   1        TM1722_Write_Byte(0xc3);         //显示寄存器的00H单元开始
1664   1        TM1722_Write_Byte(lcd_03h);     //给显示寄存器送数据，
1665   1        TM1722_STB=1;
1666   1      
1667   1      
1668   1        TM1722_Write_Byte(0x93); //显示开
1669   1        TM1722_STB=1;
1670   1      }
1671          
1672          
1673          
1674          
1675          void f_dis(bit on_off) //1--显示，0--不显示      点亮S7
1676          {
1677   1        if(on_off) {lcd_0eh=lcd_0eh|B1000_0000;       }
1678   1        else           {lcd_0eh=lcd_0eh&B0111_1111;   }
1679   1      
1680   1        TM1722_STB=1;            //端口配置初始化
1681   1        TM1722_CLK=1;
1682   1        TM1722_DIO=1;
1683   1        TM1722_Write_Byte(0x00); //工作模式
1684   1        TM1722_STB=1;
1685   1        TM1722_Write_Byte(0x44);   //固定地址模式
1686   1        TM1722_STB=1;
1687   1      
1688   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1689   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1690   1        TM1722_STB=1;
1691   1      
1692   1      
1693   1        TM1722_Write_Byte(0x93); //显示开
1694   1        TM1722_STB=1;
1695   1      }
1696          
1697          
1698          
1699          
1700          
1701          void m_dis(bit on_off) //1--显示，0--不显示      点亮S8
1702          {
1703   1        if(on_off) {lcd_0eh=lcd_0eh|B0100_0000;       }
1704   1        else           {lcd_0eh=lcd_0eh&B1011_1111;   }
1705   1      
1706   1        TM1722_STB=1;            //端口配置初始化
1707   1        TM1722_CLK=1;
1708   1        TM1722_DIO=1;
1709   1        TM1722_Write_Byte(0x00); //工作模式
1710   1        TM1722_STB=1;
1711   1        TM1722_Write_Byte(0x44);   //固定地址模式
1712   1        TM1722_STB=1;
1713   1      
1714   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1715   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1716   1        TM1722_STB=1;
1717   1      
1718   1      
1719   1        TM1722_Write_Byte(0x93); //显示开
1720   1        TM1722_STB=1;
1721   1      }
1722          
1723          
1724          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 29  

1725          
1726          void r_dis(bit on_off) //1--显示，0--不显示      点亮S9
1727          {
1728   1        if(on_off) {lcd_0eh=lcd_0eh|B0010_0000;       }
1729   1        else           {lcd_0eh=lcd_0eh&B1101_1111;   }
1730   1      
1731   1        TM1722_STB=1;            //端口配置初始化
1732   1        TM1722_CLK=1;
1733   1        TM1722_DIO=1;
1734   1        TM1722_Write_Byte(0x00); //工作模式
1735   1        TM1722_STB=1;
1736   1        TM1722_Write_Byte(0x44);   //固定地址模式
1737   1        TM1722_STB=1;
1738   1      
1739   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1740   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1741   1        TM1722_STB=1;
1742   1      
1743   1      
1744   1        TM1722_Write_Byte(0x93); //显示开
1745   1        TM1722_STB=1;
1746   1      }
1747          
1748          
1749          
1750          
1751          void p1_dis(bit on_off) //1--显示，0--不显示     点亮P1
1752          {
1753   1        if(on_off) {lcd_0ah=lcd_0ah|B0000_1000;       }
1754   1        else           {lcd_0ah=lcd_0ah&B1111_0111;   }
1755   1      
1756   1        TM1722_STB=1;            //端口配置初始化
1757   1        TM1722_CLK=1;
1758   1        TM1722_DIO=1;
1759   1        TM1722_Write_Byte(0x00); //工作模式
1760   1        TM1722_STB=1;
1761   1        TM1722_Write_Byte(0x44);   //固定地址模式
1762   1        TM1722_STB=1;
1763   1      
1764   1        TM1722_Write_Byte(0xca);         //显示寄存器的00H单元开始
1765   1        TM1722_Write_Byte(lcd_0ah);     //给显示寄存器送数据，
1766   1        TM1722_STB=1;
1767   1      
1768   1      
1769   1        TM1722_Write_Byte(0x93); //显示开
1770   1        TM1722_STB=1;
1771   1      }
1772          
1773          
1774          
1775          
1776          void p2_dis(bit on_off) //1--显示，0--不显示     点亮 P2
1777          {
1778   1        if(on_off) {lcd_07h=lcd_07h|B0000_1000;       }
1779   1        else           {lcd_07h=lcd_07h&B1111_0111;   }
1780   1      
1781   1        TM1722_STB=1;            //端口配置初始化
1782   1        TM1722_CLK=1;
1783   1        TM1722_DIO=1;
1784   1        TM1722_Write_Byte(0x00); //工作模式
1785   1        TM1722_STB=1;
1786   1        TM1722_Write_Byte(0x44);   //固定地址模式
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 30  

1787   1        TM1722_STB=1;
1788   1      
1789   1        TM1722_Write_Byte(0xc7);         //显示寄存器的00H单元开始
1790   1        TM1722_Write_Byte(lcd_07h);     //给显示寄存器送数据，
1791   1        TM1722_STB=1;
1792   1      
1793   1      
1794   1        TM1722_Write_Byte(0x93); //显示开
1795   1        TM1722_STB=1;
1796   1      }
1797          
1798          
1799          
1800          
1801          void s13_dis(bit on_off) //1--显示，0--不显示    点亮S13
1802          {
1803   1        if(on_off) {lcd_0eh=lcd_0eh|B0001_0000;       }
1804   1        else           {lcd_0eh=lcd_0eh&B1110_1111;   }
1805   1      
1806   1        TM1722_STB=1;            //端口配置初始化
1807   1        TM1722_CLK=1;
1808   1        TM1722_DIO=1;
1809   1        TM1722_Write_Byte(0x00); //工作模式
1810   1        TM1722_STB=1;
1811   1        TM1722_Write_Byte(0x44);   //固定地址模式
1812   1        TM1722_STB=1;
1813   1      
1814   1        TM1722_Write_Byte(0xce);         //显示寄存器的00H单元开始
1815   1        TM1722_Write_Byte(lcd_0eh);     //给显示寄存器送数据，
1816   1        TM1722_STB=1;
1817   1      
1818   1      
1819   1        TM1722_Write_Byte(0x93); //显示开
1820   1        TM1722_STB=1;
1821   1      }
1822          
1823          
1824          
1825          
1826          void s14_dis(bit on_off) //1--显示，0--不显示    点亮S14  旋转叶
1827          {
1828   1        if(on_off) {lcd_0fh=lcd_0fh|B0001_0000;       }
1829   1        else           {lcd_0fh=lcd_0fh&B1110_1111;   }
1830   1      
1831   1        TM1722_STB=1;            //端口配置初始化
1832   1        TM1722_CLK=1;
1833   1        TM1722_DIO=1;
1834   1        TM1722_Write_Byte(0x00); //工作模式
1835   1        TM1722_STB=1;
1836   1        TM1722_Write_Byte(0x44);   //固定地址模式
1837   1        TM1722_STB=1;
1838   1      
1839   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1840   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1841   1        TM1722_STB=1;
1842   1      
1843   1      
1844   1        TM1722_Write_Byte(0x93); //显示开
1845   1        TM1722_STB=1;
1846   1      }
1847          
1848          
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 31  

1849          void s15_dis(bit on_off) //1--显示，0--不显示    点亮S14  旋转叶中心点
1850          {
1851   1        if(on_off) {lcd_0fh=lcd_0fh|B0010_0000;       }
1852   1        else           {lcd_0fh=lcd_0fh&B1101_1111;   }
1853   1      
1854   1        TM1722_STB=1;            //端口配置初始化
1855   1        TM1722_CLK=1;
1856   1        TM1722_DIO=1;
1857   1        TM1722_Write_Byte(0x00); //工作模式
1858   1        TM1722_STB=1;
1859   1        TM1722_Write_Byte(0x44);   //固定地址模式
1860   1        TM1722_STB=1;
1861   1      
1862   1        TM1722_Write_Byte(0xcf);         //显示寄存器的00H单元开始
1863   1        TM1722_Write_Byte(lcd_0fh);     //给显示寄存器送数据，
1864   1        TM1722_STB=1;
1865   1      
1866   1      
1867   1        TM1722_Write_Byte(0x93); //显示开
1868   1        TM1722_STB=1;
1869   1      }
1870          
1871          
1872          
1873          
1874          
1875          
1876          void hot_select(uchar dd)
1877          {
1878   1       switch(dd)
1879   1        {
1880   2         case 1: {hot1_dis(1); hot2_dis(0); hot3_dis(0); H1_dis(1);  H2_dis(0); H3_dis(0); }break;    // 加热管1
1881   2         case 2: {hot1_dis(1); hot2_dis(1); hot3_dis(0); H1_dis(1);  H2_dis(1); H3_dis(0); }break;    // 加热管1+2
1882   2         case 3: {hot1_dis(1); hot2_dis(1); hot3_dis(1); H1_dis(1);  H2_dis(1); H3_dis(1); }break;    // 加热管1+2+
             -3
1883   2         case 4: {hot1_dis(1); hot2_dis(0); hot3_dis(1); H1_dis(1);  H2_dis(0); H3_dis(1); }break;    // 加热管1+3
1884   2         case 5: {hot1_dis(0); hot2_dis(1); hot3_dis(1); H1_dis(0);  H2_dis(1); H3_dis(1); }break;    // 加热管2+3
1885   2         case 6: {hot1_dis(0); hot2_dis(1); hot3_dis(0); H1_dis(0);  H2_dis(1); H3_dis(0); }break;    // 加热管2
1886   2         case 7: {hot1_dis(0); hot2_dis(0); hot3_dis(1); H1_dis(0);  H2_dis(0); H3_dis(1); }break;    // 加热管3
1887   2        }
1888   1      
1889   1      
1890   1      }
1891          
1892          
1893          
1894          
1895          
1896          
1897          void  mode_chose(void)
1898          {
1899   1       read_data();
1900   1      
1901   1       lcd_clear(0x00);  //清屏
1902   1      
1903   1      
1904   1       dis1(1,mode_num); mode_dis(1);  Delay1ms(1000);  mode_dis(0);
1905   1       
1906   1       
1907   1       dis1(1,hot_num); 
1908   1       bf_dis(1);
1909   1      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 32  

1910   1       fan_dis(fan_num);
1911   1      
1912   1       hot_select(fenduan_num);
1913   1      
1914   1       if(tb_num==1)  tb_dis(1);  else  tb_dis(0); 
1915   1      
1916   1       s13_dis(1);
1917   1       s14_dis(1);
1918   1       s15_dis(1);
1919   1      }
1920          
1921          
1922          
1923          
1924          //***********************************************************************
1925          void  pwm_set(uint pwmdata)
1926          {
1927   1       
1928   1       P_SW2 |= 0x80;      //使能访问XSFR
1929   1       PWM5T2 = pwmdata; //设置PWM4第2次反转的PWM计数
1930   1                                                     
1931   1       P_SW2 &= ~0x80;
1932   1      
1933   1      }
1934          
1935          
1936          
1937          
1938          void fan_run(void)
1939          {
1940   1       P_SW2 |= 0x80;    //使能访问XSFR
1941   1       PWMCR =0x88;      //打开PWM运行
1942   1       P_SW2 &= ~0x80;
1943   1      
1944   1      }
1945          
1946          
1947          
1948          
1949          
1950          void fan_stop(void)
1951          {
1952   1       pwm_set(10);
1953   1       P_SW2 |= 0x80;    //使能访问XSFR
1954   1       PWMCR =0x00;     //关闭PWM
1955   1       P_SW2 &= ~0x80;
1956   1       pwm5=10;
1957   1      
1958   1      }
1959          
1960          
1961          
1962          
1963          
1964          void fan_run_stop(uchar dd)      //风量风扇启动或停止
1965          {
1966   1       switch(dd)
1967   1        {
1968   2         case 0: { fan_stop();  fan_bit=0; }break;
1969   2      
1970   2         case 1: { fan_run(); pwm5=2000; pwm_set(pwm5); fan_bit=1;}break;      //500
1971   2      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 33  

1972   2         case 2: { fan_run(); pwm5=2400; pwm_set(pwm5); fan_bit=1;}break;      //1000
1973   2      
1974   2         case 3: { fan_run(); pwm5=2800; pwm_set(pwm5); fan_bit=1;}break;      //1500
1975   2      
1976   2         case 4: { fan_run(); pwm5=3200; pwm_set(pwm5); fan_bit=1;}break;     //2200
1977   2      
1978   2         case 5: { fan_run(); pwm5=3600; pwm_set(pwm5); fan_bit=1;}break;      //3200
1979   2      
1980   2         case 6: { fan_run(); pwm5=4000; pwm_set(pwm5); fan_bit=1;}break;      //4000
1981   2      
1982   2        }
1983   1      
1984   1      }
1985          
1986          //***********************************************************************
1987          
1988           
1989          
1990          
1991          
1992          
1993          
1994          
1995          void Uart() interrupt 4 using 1
1996          {
1997   1       
1998   1       if(RI)
1999   1        {
2000   2         RI=0;
2001   2                              
2002   2         ribuf1[ri_cnt] = SBUF;
2003   2         
2004   2         if(SBUF==0xff) 
2005   2           {
2006   3                   nn[jj]=ri_cnt;
2007   3                       
2008   3      
2009   3                   if(jj==1)       { if(nn[1]-nn[0]==1) jj++; else { nn[0]=nn[1]; jj=1;}}
2010   3               else if(jj==2)  { if(nn[2]-nn[1]==1) jj++; else { nn[0]=nn[2]; jj=1;}}
2011   3                       else jj++;                                              
2012   3      
2013   3              if(jj>2) //检测到连续发过来的0xff
2014   3                {
2015   4                          ES=0;
2016   4                      jj=0;  
2017   4                              ri_cnt=0;
2018   4                      uart_ok=1;
2019   4                        }
2020   3        
2021   3                }
2022   2          ri_cnt++; if(ri_cnt>20) {ri_cnt=0;  jj=0;}
2023   2         }
2024   1      }
2025          
2026          //****************************************************************************************
2027          
2028          //***********************************************************************
2029          void time_inset(void)
2030          {
2031   1       tt1=time+58400;         //time=0时，  50Hz(59979) 最低8.2ms     60Hz(60885) 最低6ms     58163(10ms )
2032   1       tt2=65000;
2033   1      }
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 34  

2034          
2035          
2036          
2037          void exint0()  interrupt 0 using 1        //(location at 0003H)   外部中断INT0
2038          {                                          
2039   1       out1=out2=out3=1;      
2040   1       TL0 = tt1;             //设置定时初值
2041   1       TH0 = tt1>>8;  //设置定时重载值
2042   1       zb_bit=0;
2043   1       TF0=0;
2044   1       ET0=1;
2045   1       TR0=1;  
2046   1       
2047   1        
2048   1      
2049   1      }
2050          
2051          
2052          
2053          void tm0_isr() interrupt 1  using 2     
2054          {
2055   1       if(zb_bit==0) {
2056   2                                      switch(fenduan_num)
2057   2                         {
2058   3                           case 1: {out1=0; }break;
2059   3                                               case 2: {out1=0; out2=0; }break;
2060   3                                               case 3: {out1=0; out2=0; out3=0; }break;
2061   3                                               case 4: {out1=0; out3=0; }break;
2062   3                                               case 5: {out2=0; out3=0; }break;
2063   3                                               case 6: {out2=0; }break;
2064   3                                               case 7: {out3=0; }break;
2065   3      
2066   3                                              }
2067   2                      
2068   2                      TR0=0;  
2069   2                                      TL0 = tt2;              //设置定时初值
2070   2                      TH0 = tt2>>8;   //设置定时重载值
2071   2                                      TF0=0;
2072   2                                      TR0=1;
2073   2                                      zb_bit=1;
2074   2                                      
2075   2                                  }
2076   1       else  {out1=out2=out3=1;  TR0=0; ET0=0;}
2077   1      }
2078          
2079          
2080          
2081          
2082          
2083          
2084          
2085          
2086          
2087          
2088          //******************************************************************************************
2089          /* T0 中断服务函数，产生 PWM 输出 */
2090          /*
2091          void InterruptTimer0() interrupt 1 using 2{
2092              if (PWMOUT == 1){ //当前输出为高电平时，装载低电平值并输出低电平
2093                  TH0 = LowRH;
2094                  TL0 = LowRL;
2095                  PWMOUT = 0;
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 35  

2096                          led6=out2=1;
2097                          //out2=out3=1;
2098              }else{ //当前输出为低电平时，装载高电平值并输出高电平
2099                  TH0 = HighRH;
2100                  TL0 = HighRL;
2101                  PWMOUT = 1;
2102                          led6=0;
2103                          out2=0;
2104                          //out2=out3=0;
2105              }
2106          }
2107          
2108           */
2109          
2110          
2111          
2112          
2113          
2114          void t3int() interrupt 19  using 3        //50ms  定时器3  11.0592
2115          {
2116   1      
2117   1       key_buf=P0&0x0f; //每50ms 扫描一次按键
2118   1      
2119   1       //if(key_buf==0x0f)  key_find_bit=0;
2120   1      
2121   1      
2122   1       if(fan_close_bit) //同步信号关，风机延时关闭
2123   1         {
2124   2              cnt4++;
2125   2              if(cnt4>19) //1秒钟到    1200 为1分钟
2126   2                {
2127   3                  cnt4=0; 
2128   3                      cnt5++;   
2129   3                      if(cnt5>=fan_close_cnt)  {cnt5=0; fan_close_ok=1;}
2130   3                        
2131   3                }
2132   2              
2133   2         }
2134   1      
2135   1       dis_temp_cnt++; //温度检测0.5秒检测一次
2136   1       if(dis_temp_cnt>10) {dis_temp_cnt=0; dis_temp_bit=1;}
2137   1      
2138   1      
2139   1       if(fan_bit)  //风扇图标旋转
2140   1         {
2141   2              fan_cnt++;
2142   2              if(fan_cnt>2)  { fan_cnt=0; fan_bit2=1; fan_bit3=~fan_bit3; }
2143   2         }
2144   1      
2145   1      
2146   1       if(sp_bit==0)
2147   1        {
2148   2         cnt3++;
2149   2         if(cnt3>2) {cnt3=0; speak=sp_bit=1;}
2150   2        
2151   2        } 
2152   1      
2153   1      
2154   1      
2155   1      
2156   1      
2157   1      if(power_bit==0) //待机电源按键指示闪烁
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 36  

2158   1        {
2159   2         
2160   2         if(power_cnt>9) { led5=~led5; power_cnt=0; }
2161   2         else power_cnt++;
2162   2      
2163   2        }
2164   1      
2165   1      
2166   1      
2167   1      
2168   1      
2169   1      if(temp_set_bit)  //温度设定时数字闪烁
2170   1       {
2171   2        save_cnt++;
2172   2        if(save_cnt>40) {save_cnt=0;  save_bit=1; } //2秒后保存修改值
2173   2      
2174   2      
2175   2        if(temp_set_cnt>9) {temp_set_cnt=0;   ss_bit=~ss_bit;}
2176   2        else temp_set_cnt++;
2177   2      
2178   2       }
2179   1      
2180   1      else {
2181   2                ss_cnt++;
2182   2                if(ss_cnt>60) { ss_cnt=0; hot_HT_bit=1;}
2183   2            }
2184   1      
2185   1            
2186   1          if(preheating_scan_bit == 1)
2187   1          {
2188   2              preheating_scan_cnt++;
2189   2              if(preheating_scan_cnt == 200)  //10s
2190   2              {
2191   3                  preheating_strat_bit = 1;
2192   3                  preheating_scan_bit = 0;
2193   3                  preheating_scan_cnt = 0;
2194   3              }
2195   2          }
2196   1          if(preheating_strat_bit == 1)
2197   1          {
2198   2              preheating_strat_cnt++;
2199   2              if(preheating_strat_cnt == 200)  //10s
2200   2              {
2201   3                  preheating_strat_bit = 0;
2202   3                  preheating_strat_cnt = 0;
2203   3              } 
2204   2          }
2205   1      
2206   1      
2207   1      }
2208          
2209          
2210          
2211          //******************************************************************************************************
2212          
2213          void main(void)
2214          { /*
2215   1         tm1=PID(120,29);
2216   1               
2217   1         tm1=PID(120,60);
2218   1        
2219   1         tm1=PID(120,80);
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 37  

2220   1        
2221   1         tm1=PID(120,110);
2222   1         
2223   1         tm1=PID(120,118); 
2224   1        
2225   1         tm1=PID(120,119); 
2226   1      
2227   1         tm1=PID(120,121); */
2228   1      
2229   1         hot_ok=0;
2230   1         hot_fan=0;
2231   1         lcd_bl=1;
2232   1         power_bit=1;
2233   1      
2234   1          P0M0 =B0110_0000;  ////P0.5 P0.6 设置成推勉输出
2235   1          P0M1 = 0x00;
2236   1              
2237   1                       
2238   1      
2239   1          P1M0 = B1100_0000;  //P1.6, P1.7设置成推勉输出
2240   1          P1M1 = 0x00;
2241   1      
2242   1      
2243   1          P2M0 = B1000_1110; //P2 1,2,3,7设置成推勉输出
2244   1          P2M1 = 0x00;
2245   1      
2246   1      
2247   1          P3M0 = 0x00;   //普通IO
2248   1          P3M1 = 0x00;
2249   1      
2250   1          P4M0 = 0x00;  //普通IO
2251   1          P4M1 = 0x00;
2252   1      
2253   1          P5M0 = 0x00;
2254   1          P5M1 = 0x00;
2255   1      
2256   1              out1=out2=out3=1;
2257   1      
2258   1              
2259   1      //***************************************************************************
2260   1              P_SW2 |= 0x80;                  //使能访问XSFR
2261   1          PWMCFG = 0x08;                  //配置PWM5的输出初始电平为高电平
2262   1              //PWMCR  = 0x04;                                        //配置PWM通道2、3、4、5受PWM波形发生器控制
2263   1          PWMCKS = 0x0b;                  //选择PWM的时钟为Fosc/12
2264   1          PWMC = CYCLE;                   //设置PWM周期
2265   1                                                              //输出频率=11059200/12/4096=225Hz
2266   1       //----------------------------------------------------------------------------------
2267   1          PWM5T1 = 0;                  //设置PWM5第1次反转的PWM计数
2268   1          PWM5T2 = 10;                //设置PWM5第2次反转的PWM计数
2269   1                                          //占空比为(PWM5T2-PWM5T1)/PWMC
2270   1          PWM5CR = 0x00;                  //选择PWM5输出到P2.3,不使能PWM5中断
2271   1       //----------------------------------------------------------------------------------
2272   1      
2273   1      
2274   1              PWMFDCR=0x30;                   //打开PWM外部异常功能并发生PWM外部异常时，PWM的输出口立即被设置为高阻输入
             -模式
2275   1          
2276   1          //PWMCR |= 0x80;                  //使能PWM模块
2277   1      
2278   1          P_SW2 &= ~0x80;
2279   1      
2280   1      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 38  

2281   1      //**********************************************************************************
2282   1        /*     
2283   1        ACC = P_SW1;                            //串口1切换
2284   1        ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
2285   1        ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
2286   1        P_SW1 = ACC; 
2287   1                      
2288   1                */
2289   1                                                                //串口2切换
2290   1       
2291   1      
2292   1                                                                //PWM口切换
2293   1              //P_SW2 &=~PWM2345_S;     //PWM_2345_S=0 P3.7/PWM2 P2.1/PWM3 P2.2/PWM4 P2.3/PWM5 P2.4/PWMFLT
2294   1              //P_SW2 |= PWM2345_S;             //PWM_2345_S=1 P2.7/PWM2 P4.5/PWM3 P4.4/PWM4 P4.2/PWM5 P0.5/PWMFLT
2295   1      
2296   1      
2297   1       
2298   1        
2299   1       UartInit();
2300   1      
2301   1       InitADC();
2302   1      
2303   1       Timer0Init();
2304   1      
2305   1       Timer1Init();
2306   1      
2307   1       Timer3Init();
2308   1         
2309   1       //ES=1;
2310   1      
2311   1       //IT0 = 0;    //设置INT0的中断类型为上升沿和下降沿
2312   1      
2313   1       IT0 = 1;      //设置INT0的中断类型为仅下降沿
2314   1       
2315   1      
2316   1       EA=1;
2317   1      
2318   1       read_mode();   
2319   1       read_data();
2320   1       fan_close_read();
2321   1      
2322   1       nop;
2323   1       restar: nop; nop;
2324   1      
2325   1       lcd_clear(0x00);
2326   1      
2327   1       hot_in=1;
2328   1      
2329   1               
2330   1      
2331   1       if(key_buf==fn_key)  //设定风扇延时关闭时间，按住功能键上电进入
2332   1        {
2333   2         speak=sp_bit=0;
2334   2         lcd_bl=0;
2335   2         led2=led1=led3=0;
2336   2         dis1(1,fan_close_cnt);
2337   2      
2338   2         while(key_buf==fn_key) WDT_CONTR=0X34;
2339   2      
2340   2         while(1)
2341   2           {
2342   3                Delay1ms(50);
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 39  

2343   3      
2344   3                if(key_buf==up_key)      {speak=sp_bit=0; fan_close_cnt++; if(fan_close_cnt>250) fan_close_cnt=250; dis
             -1(1,fan_close_cnt);   Delay1ms(100);}
2345   3      
2346   3                else if(key_buf==dn_key) {speak=sp_bit=0; fan_close_cnt--; if(fan_close_cnt<1)   fan_close_cnt=1;   dis
             -1(1,fan_close_cnt);   Delay1ms(100);}
2347   3      
2348   3                else if(key_buf==fn_key) {speak=sp_bit=0; fan_close_save();  while(key_buf==fn_key) WDT_CONTR=0X34; bre
             -ak;}
2349   3               }
2350   2              led1=led2=led3=1;
2351   2              led4=led6=1;
2352   2              lcd_clear(0x00); 
2353   2              lcd_bl=1;
2354   2        }
2355   1      
2356   1      
2357   1       led5=0;
2358   1       out_clear_cnt=0;
2359   1      
2360   1       while(1)
2361   1        {
2362   2         Delay1ms(50);
2363   2         if(key_buf==power_key) 
2364   2          {
2365   3               speak=sp_bit=0; 
2366   3               led5=1;
2367   3               lcd_clear(0xff); 
2368   3               lcd_bl=0; 
2369   3               power_bit=1;  
2370   3               led6=0;        Delay1ms(200);
2371   3               led4=0;        Delay1ms(200);
2372   3               led2=0;        Delay1ms(200);
2373   3               led1=0;        Delay1ms(200);
2374   3               led3=0;        Delay1ms(200);
2375   3               led5=0;        
2376   3               Delay1ms(1000);
2377   3               lcd_clear(0x00);
2378   3               
2379   3               //led1=led2=led3=1;
2380   3               //led4=led6=1;
2381   3               break;
2382   3              }
2383   2      
2384   2         out_clear_cnt++;
2385   2         if(out_clear_cnt>20)  {out_clear_cnt=0;  out1=out2=out3=1;}
2386   2      
2387   2        }
2388   1      
2389   1       restar2: nop; nop;
2390   1      
2391   1       led1=led2=led3=0;
2392   1       led4=led6=0;
2393   1       tb_bit=0;
2394   1      
2395   1       mode_chose();
2396   1                        
2397   1       led5=0;
2398   1      
2399   1       save_bit=0;
2400   1      
2401   1       tm1=Temperature_LPF(0);         //上电后先读取一次温度值
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 40  

2402   1       tm1 =get_temperature(tm1);     //计算温度值
2403   1      
2404   1      
2405   1       hot_HT_bit=0;
2406   1       hot_fan_bit=0;
2407   1       ss_cnt=0;
2408   1       auto_bit=0;
2409   1      
2410   1       hot_fan=1;        //测试下风扇输出有没有
2411   1       Delay1ms(200);
2412   1       hot_fan=0;
2413   1       
2414   1       s13_dis(1); s14_dis(0);
2415   1      
2416   1       while(1)
2417   1       {
2418   2         WDT_CONTR=0X34;
2419   2           
2420   2          if(tb_num==1) //检测同步功能有没有打开
2421   2          {
2422   3              if((hot_in == 0)&&(turn_bit == 0))  //检测到有同步信号过来 - 高电平
2423   3              {
2424   4                  preheating_scan_bit = 1;   
2425   4                  turn_bit = 1;
2426   4              }
2427   3              if(hot_in==1)  //低电平
2428   3              {
2429   4                  preheating_scan_bit = 0;  
2430   4                  preheating_strat_bit = 0;  
2431   4                  preheating_scan_cnt = 0;
2432   4                  preheating_strat_cnt = 0;
2433   4                  turn_bit = 0;            
2434   4              }
2435   3              if(preheating_strat_bit == 1)
2436   3              {
2437   4                  tt1 = 65000;
2438   4                  dis1(1,100);
2439   4              }
2440   3              if(preheating_strat_bit == 0)
2441   3              {
2442   4                  time_inset();
2443   4                  dis1(1,hot_num);
2444   4              } 
2445   3          }
2446   2           
2447   2         if(tb_num==1) //检测同步功能有没有打开
2448   2           {
2449   3      
2450   3              if(hot_in==0)  //检测到有同步信号过来
2451   3               {
2452   4                     if(tb_bit==0)
2453   4                               { 
2454   5                                tb_bit=1;
2455   5                                auto_bit=0;
2456   5                                fan_close_bit=0; //关闭风扇延时关闭
2457   5      
2458   5                                if(hot_num>0)
2459   5                                 {
2460   6                                  fan_run_stop(fan_num);  //打开风扇
2461   6      
2462   6                                  hot_dis(1);  //显示加热标志
2463   6      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 41  

2464   6                                  time=hot_num*64; if(time>time_max)  time=time_max;  
2465   6                                  time_inset();
2466   6                                  TH1=TL1=0; IE0=0; EX0=1; //启动加热                                           
2467   6                                 }
2468   5      
2469   5                        }
2470   4                    }
2471   3                       else { //检测到有同步信号关闭
2472   4                                 if(tb_bit==1)
2473   4                                   {
2474   5                                         tb_bit=0;
2475   5                                     auto_bit=0;
2476   5                                         cnt4=cnt5=0;
2477   5                                         fan_close_bit=1;  //打开风扇延时关闭
2478   5      
2479   5                                         hot_dis(0);  //关闭加热标志
2480   5      
2481   5                                         EX0=0; TR1=0; ET0=0;  //关闭加热
2482   5                                         out1=out2=out3=1;
2483   5                                        }
2484   4      
2485   4                                      if(fan_close_ok) {fan_close_ok=0; fan_stop(); fan_bit=0;}
2486   4      
2487   4                             }
2488   3      
2489   3                }
2490   2      
2491   2              else { //没有打开同步功能，按设置状态自动运行
2492   3                        if(auto_bit==0)
2493   3                          {
2494   4                               auto_bit=1;
2495   4                               
2496   4                               fan_run_stop(fan_num); //打开风量
2497   4      
2498   4                               if(hot_num>0)
2499   4                                {
2500   5                                 hot_dis(1);  //显示加热标志
2501   5      
2502   5                                 time=hot_num*64; if(time>time_max)   time=time_max;  
2503   5                                 time_inset();
2504   5                                 TH1=TL1=0; IE0=0; EX0=1; //启动加热
2505   5                                }
2506   4                               else hot_bit=1;
2507   4                              }
2508   3      
2509   3                   }
2510   2      
2511   2      
2512   2      
2513   2         //风扇图标旋转显示
2514   2         if(fan_bit2) { fan_bit2=0;  if(fan_bit3) {s13_dis(1); s14_dis(0);} else {s13_dis(0); s14_dis(1);} }
2515   2      
2516   2      
2517   2      
2518   2      
2519   2         if(dis_temp_bit)
2520   2          {
2521   3               dis_temp_bit=0;
2522   3      
2523   3           tm1=Temperature_LPF(0);
2524   3           tm1 =get_temperature(tm1); //计算温度值
2525   3      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 42  

2526   3               tm6=Temperature_LPF(5);        //测量可控管温度
2527   3           tm6 =get_temperature(tm6); //计算温度值
2528   3      
2529   3               if((dis_ss_bit==1)&&(temp_set_bit==0))  { if(tm1>0) dis1(1,tm1); }
2530   3      
2531   3               if(tm1>=temp_set)   hot_ok=1; 
2532   3               else                hot_ok=0;
2533   3      
2534   3      
2535   3               if((tm6>45)&&(hot_fan_bit==0))      {  hot_fan=1;   hot_fan_bit=1; } //打开散热风扇
2536   3      
2537   3               else if((tm6<40)&&(hot_fan_bit==1)) {  hot_fan=0;   hot_fan_bit=0; power_bit=1; led5=0;} //关闭散热风扇
2538   3      
2539   3               if(tm6>100)  { power_bit=0; if(led5) {speak=sp_bit=0; jg_dis(0);} else jg_dis(1); }
2540   3      
2541   3                if(tm6>118)  { 
2542   4                               EX0=0; TR1=0; ET0=0;    //关闭加热
2543   4                                           out1=out2=out3=1; 
2544   4                                               hot_dis(0);  //关闭加热标志
2545   4                                               jg_dis(1);
2546   4                                               hot_ok=1; //给主板发高电平信号
2547   4                                                //显示警告标志
2548   4                                               while(1){
2549   5                                                                Delay1ms(100);
2550   5                                                                if(led5) { speak=sp_bit=0;  }
2551   5                                                                
2552   5                                                                if(key_buf==power_key)  //检测电源按键
2553   5                                                                      {
2554   6                                                                        speak=sp_bit=0;
2555   6                                                        lcd_clear(0x00); 
2556   6                                            lcd_bl=1;
2557   6                                                        fan_bit=0;
2558   6                                                        auto_bit=0;
2559   6                                                        led1=led2=led3=1;
2560   6                                            led4=led5=led6=1;
2561   6      
2562   6                                                        EX0=0; TR1=0; ET0=0;   //关闭加热
2563   6                                                        out1=out2=out3=1;
2564   6      
2565   6                                                        fan_stop();  //关闭风扇
2566   6      
2567   6                                                        while(key_buf==power_key) WDT_CONTR=0X34;
2568   6      
2569   6                                                        goto  restar;
2570   6      
2571   6                                                                      }
2572   5                                                       }
2573   4      
2574   4                                         }
2575   3      
2576   3              }
2577   2      
2578   2      
2579   2      
2580   2      
2581   2      
2582   2         if(hot_HT_bit) //实测温度和加热设定值循环显示
2583   2            {
2584   3                 hot_HT_bit=0;                
2585   3                                         
2586   3      
2587   3             if(dis_ss_bit) {dis_ss_bit=0; temp_dis(0); bf_dis(1); dis1(1,hot_num); }  //显示加执设定值 
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 43  

2588   3                
2589   3                 else           {dis_ss_bit=1; if(tm1>0) {temp_dis(1); bf_dis(0); dis1(1,tm1);}} //显示实测温度值
2590   3                } 
2591   2         
2592   2      
2593   2      
2594   2      
2595   2      
2596   2      
2597   2      
2598   2                                              
2599   2         //自动保存修改的数据
2600   2         if(save_bit) {speak=sp_bit=0;save_bit=0; temp_set_bit=0; hot_HT_bit=1; save_mode_wr(); }
2601   2      
2602   2      
2603   2      
2604   2      
2605   2      
2606   2         if(key_buf==power_key)  //检测电源按键
2607   2            {
2608   3                  t_cnt=150;
2609   3                                  
2610   3              while((key_buf==power_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2611   3                  if(t_cnt==0) //长按1.5秒关机 
2612   3                                    {
2613   4                                         speak=sp_bit=0;
2614   4                                         lcd_clear(0x00); 
2615   4                             lcd_bl=1;
2616   4                                         fan_bit=0;
2617   4                                         auto_bit=0;
2618   4                                         led1=led2=led3=1;
2619   4                             led4=led5=led6=1;
2620   4      
2621   4                                         hot_fan=0;
2622   4      
2623   4                                         EX0=0; TR1=0; ET0=0;  //关闭加热
2624   4                                         out1=out2=out3=1;
2625   4      
2626   4                                         hot_dis(0);  //关闭加热标志
2627   4      
2628   4                                         fan_stop();  //关闭风扇
2629   4      
2630   4                                         while(key_buf==power_key) WDT_CONTR=0X34;
2631   4      
2632   4                                         goto  restar;
2633   4      
2634   4                                        }
2635   3                }
2636   2      
2637   2      
2638   2               //按fn键消除散热报警的电源按键灯闪动
2639   2              if((key_buf==fn_key)&&(power_bit==0))      {speak=sp_bit=0;     power_bit=1; led5=0;  while(key_buf==fn_key)
             - WDT_CONTR=0X34;}
2640   2      
2641   2      
2642   2          //风力加
2643   2         if(key_buf==fn_up_key)      {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; fan_num++; if(fan_num>6)   fan
             -_num=6;     fan_dis(fan_num); if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==fn_up_ke
             -y) WDT_CONTR=0X34;}
2644   2      
2645   2         //风力减
2646   2         else if(key_buf==fn_dn_key) {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; if(fan_num==0) fan_num=0; else
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 44  

             - fan_num--; fan_dis(fan_num); if((tb_num==0)||((tb_num==1)&&(hot_in==0))) fan_run_stop(fan_num); while(key_buf==fn_dn_ke
             -y) WDT_CONTR=0X34;}
2647   2      
2648   2         
2649   2         else if(key_buf==up_key) //加热加    
2650   2             {
2651   3                   speak=sp_bit=0; temp_dis(0); bf_dis(1); temp_set_bit=1; 
2652   3      
2653   3                       save_cnt=0; hot_num+=5; if(hot_num>100) hot_num=100; dis1(1,hot_num); 
2654   3      
2655   3                       time=hot_num*64; if(time>time_max)     time=time_max;  time_inset();
2656   3      
2657   3                       if((hot_bit==1)&&(tb_num==0))  {hot_bit=0; TH1=TL1=0; IE0=0; EX0=1; }//启动加热
2658   3      
2659   3                       else if((hot_in==0)&&(tb_num==1))       { TH1=TL1=0; IE0=0; EX0=1; }//启动加热
2660   3      
2661   3                       while(key_buf==up_key) WDT_CONTR=0X34;
2662   3                      }
2663   2      
2664   2         
2665   2         else if(key_buf==dn_key)  //加热减  
2666   2             {
2667   3                  speak=sp_bit=0; temp_dis(0); bf_dis(1); temp_set_bit=1;
2668   3      
2669   3                  save_cnt=0; if(hot_num>=5) hot_num-=5;  dis1(1,hot_num);
2670   3      
2671   3                      if(hot_num<5) {hot_num=0; EX0=0; TR1=0; ET0=0; out1=out2=out3=1; bf_dis(0); if(tb_num==0) hot_bit=1;} 
2672   3      
2673   3                      else {time=hot_num*64; if(time>time_max)        time=time_max;  time_inset(); }
2674   3                      
2675   3                      while(key_buf==dn_key) WDT_CONTR=0X34;
2676   3                      
2677   3                 }
2678   2      
2679   2      
2680   2         //模式选择
2681   2         if(key_buf==mode_key)  
2682   2          {
2683   3               t_cnt=150;
2684   3                                  
2685   3            while((key_buf==mode_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2686   3                if(t_cnt==0) //长按1.5秒进入同步设定 
2687   3                                    {
2688   4                                         speak=sp_bit=0;
2689   4      
2690   4                                         if(tb_num==0) {tb_num=1; tb_dis(1);}
2691   4      
2692   4                                         else          {tb_num=0; tb_dis(0);}
2693   4      
2694   4                                         while(key_buf==mode_key) WDT_CONTR=0X34;
2695   4      
2696   4                                         //temp_set_bit=1; save_cnt=0;
2697   4                                         save_mode_wr();
2698   4      
2699   4                                         fan_bit=0;
2700   4                                       
2701   4                                         led1=led2=led3=1;
2702   4                             led4=led5=led6=1;
2703   4      
2704   4                                         EX0=0; TR1=0; ET0=0;  //关闭加热
2705   4                                         out1=out2=out3=1;
2706   4      
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 45  

2707   4                                         hot_dis(0);  //关闭加热标志
2708   4      
2709   4                                         fan_stop();  //关闭风扇
2710   4      
2711   4                                         goto  restar2;
2712   4                                        }
2713   3                      
2714   3                 else { //模式选择
2715   4                       speak=sp_bit=0; fan_bit=0; auto_bit=0; temp_set_bit=1; save_cnt=0; mode_num+=1; if(mode_num>5) m
             -ode_num=1; mode_chose(); save_mode_num(); while(key_buf==mode_key) WDT_CONTR=0X34; 
2716   4                               if(tb_num==1)   
2717   4                                               { tb_bit=0; 
2718   5                                                                 EX0=0; TR1=0; ET0=0;  //关闭加热
2719   5                                                 out1=out2=out3=1;  
2720   5                                                                 hot_dis(0);  //关闭加热标志
2721   5                                                                 fan_stop();  //关闭风扇
2722   5                                                                }
2723   4      
2724   4                                if(hot_num==0) 
2725   4                                               { tb_bit=0; 
2726   5                                                                 EX0=0; TR1=0; ET0=0;  //关闭加热
2727   5                                                 out1=out2=out3=1;  
2728   5                                                                 hot_dis(0);  //关闭加热标志
2729   5                                                                 fan_stop();  //关闭风扇
2730   5                                                                 if(tb_num==0) hot_bit=1;
2731   5                                                                 else          hot_bit=0;
2732   5                                                                }
2733   4                 
2734   4                       }      
2735   3                               
2736   3              }
2737   2      
2738   2         
2739   2         
2740   2         //分段选择或温度设定
2741   2         if(key_buf==fd_key) //减键 
2742   2           { 
2743   3                                t_cnt=150;
2744   3                                  
2745   3      
2746   3                            while((key_buf==fd_key)&&(t_cnt>0)) {t_cnt--; Delay1ms(10);}
2747   3      
2748   3                                if(t_cnt==0) //长按1.5秒进入温度设定 
2749   3                                    {
2750   4                                         speak=sp_bit=0; 
2751   4                                         temp_dis(1);
2752   4                                         bf_dis(0);
2753   4                                         dis1(1,temp_set);
2754   4                                         temp_set_bit=1;
2755   4                                         while(key_buf==fd_key) 
2756   4                                           {
2757   5                                                 WDT_CONTR=0X34;
2758   5      
2759   5                                                 if(ss_bit) dis1(1,temp_set);  else dis1(0,temp_set);
2760   5                                               }
2761   4      
2762   4      
2763   4                                         while(1)
2764   4                                           {
2765   5                                                Delay1ms(30);
2766   5      
2767   5                                                if(ss_bit) dis1(1,temp_set);  else dis1(0,temp_set);
C51 COMPILER V9.60.7.0   ________                                                          11/13/2024 11:01:10 PAGE 46  

2768   5      
2769   5                                                if(key_buf==up_key)         {speak=sp_bit=0; temp_set+=1; if(temp_set>200) temp_set=200; dis1(1,tem
             -p_set); Delay1ms(150);}
2770   5      
2771   5         
2772   5                            else if(key_buf==dn_key)    {speak=sp_bit=0; temp_set-=1; if(temp_set<50) temp_set=5
             -0;   dis1(1,temp_set); Delay1ms(150);}
2773   5      
2774   5      
2775   5                                                else if(key_buf==fd_key)        {speak=sp_bit=0; while(key_buf==fd_key) WDT_CONTR=0X34; save_mode_wr(); 
             -break;}
2776   5      
2777   5                                               }
2778   4      
2779   4                                         
2780   4                                         temp_set_bit=0;
2781   4                                         save_bit=0;
2782   4                                         temp_dis(0);
2783   4                                         bf_dis(1);
2784   4                                         dis1(1,hot_num);
2785   4                                                
2786   4                                        }
2787   3                                else {speak=sp_bit=0; temp_set_bit=1; save_cnt=0; fenduan_num++; if(fenduan_num>7) fenduan_num=1; hot
             -_select(fenduan_num); while(key_buf==fd_key) WDT_CONTR=0X34;}
2788   3                                              //短按分段选择
2789   3                }
2790   2         
2791   2                        
2792   2      
2793   2        
2794   2         
2795   2       }
2796   1                         
2797   1         
2798   1      
2799   1      
2800   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5747    ----
   CONSTANT SIZE    =    260    ----
   XDATA SIZE       =     14    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      14
   IDATA SIZE       =    123    ----
   BIT SIZE         =     25      23
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
